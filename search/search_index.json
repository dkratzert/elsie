{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Elsie # Elsie allows you to create slides programmatically using Python. It is a Python library that lets you build SVG slides in a composable way and then render them to PDF. There is no DSL or GUI \u2013 presentations created with Elsie are fully programmed with Python. It was created out of frustration of having to deal with existing tools for creating technically oriented presentations. We believe that creating presentations in a programmable way makes the slide-making process more smooth and reliable. Quick links Installation Getting started User guide Gallery API Reference Elsie example # import elsie slides = elsie.SlideDeck() @slides.slide() def hello_world(slide): import datetime slide.box().text(f\"Hello from\") year = str(datetime.datetime.now().year) row = slide.box(horizontal=True, p_top=20) for i in range(4): row.box(width=40, height=40).rect( color=\"black\", bg_color=\"black\" if i % 2 == 0 else \"white\" ).text(year[i], elsie.TextStyle(color=\"red\")) slides.render(\"slides.pdf\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Features # Layout model Elsie provides a simple, yet powerful layout model. Rows, columns, padding, text alignment, relative/absolute positioning and many other layout features are included. Animations and fragments Reveal your slides gradually using fragments and build complex step-by-step animations in Python. Or draw a fine-tuned SVG image by hand e.g. in Inkscape and let Elsie turn it into an animation using a handy layer-naming convention . Source code highlighting Enjoy beautiful code snippets thanks to built-in source code highlighting . Create code walkthroughs using individual line highlighting or arrows pointing to specific code elements. Batteries included Leverage familiar SVG features - fonts, colors, dashed line borders. Include PNG/JPG/SVG/ORA images or render Markdown or LaTeX directly into your slides. Build your slides interactively in Jupyter notebooks . Familiarity At its heart, Elsie is a streamlined API for creating SVG images, optimized for making presentations. If you know the basics of Python and SVG, you'll be right at home. The ultimate feature of Elsie is that it allows you to build slides using (an imperative) programming language. You can split a large presentation into several modules/files, parametrize animations or objects that appear often using functions, create arbitrarily complex slides and animations or interactively modify the font, aspect ratio or text color/size of your whole presentation by changing a single line of code. Every tool has its disadvantages though. Elsie provides a rather low-level API. While that means that you can create a slide in almost any way you like, you will sometimes have to roll up your sleeves to achieve your desired goal. However, once you implement it, you can put it inside a function and reuse it the next time, or send us a Pull Request to share the functionality with others. Elsie produces PDF slides, so it can only create animations with a single frame per page. If you need 60 FPS animations or GIFs in your presentations, this tool is not for you. Elsie currently renders SVG slides to PDF using Inkscape . Therefore, you must have it installed on your system for it to work. We provide a Docker image with Inkscape for convenience. Elsie is tested only on Linux. If you find a problem on a different platform, do not hesitate to open a GitHub issue . Comparison to other tools # Google slides/PowerPoint These tools are fine if you need to make a bunch of very simple slides quickly, but using them gets very annoying if you need anything more complex. You need to place all items manually, alignment is usually a mess, fragments (animations) are not supported very well. If you need to change some small detail (placement, style, color) of a thing that is repeated on many slides, you pretty much have to go through all the slides and modify them by hand, one by one. Displaying source code with syntax highlighting is notoriously badly supported, so often you have to resort to exporting the highlighted code from carbon.sh or screenshotting it from your IDE, both of which are far from ideal. Also, you can't really use source control (e.g. git ) to version your slides, which is a shame. However, PowerPoint does allow you to create continuous animations (if you do not export to PDF of course), so if you need that, it might be a good choice. It also has a myriad of other useful features, like tables, charts, shared templates, spell checking, etc. LaTeX/Beamer LaTeX has a template called Beamer , which is designed for creating presentation slides. It produces fine-looking text, has good support for syntax highlighting and can be versioned easily. However, in our experience it is not that easy to create custom diagrams and animations using LaTeX, mainly because of its declarative nature (and somewhat confusing syntax). If you can speak fluently in TikZ and you can understand the error messages of pdflatex , you are probably fine. If not, creating slides with complex animations, diagrams and source code snippets might be easier for you in Python. While Elsie also has basic support for rendering LaTeX , if your presentation is mostly composed of math formulas, it might be easier to create it in LaTeX directly. Reveal.js reveal.js is a great tool for making HTML presentations. It supports syntax highlighting, has good-looking animations and can be versioned. However, it shares some disadvantages of LaTeX/Beamer, which stems from the fact that it is also declarative. Creating an animation that would walk line-by-line through a source code snippet or that would repeatedly display and hide objects in custom fragments is difficult. You can actually use JavaScript to create more complex animations, but it's not integrated very well, and the library itself does not offer you any API to make it easier. That being said, if you are fine with declarative description of slides, and you prefer HTML/CSS to Python/SVG, reveal.js is a fine choice. Prezi If you like presentations with three or more dimensions, it's a good choice. Otherwise, the disadvantages of PowerPoint also apply here. python-pptx python-pptx is an API for building PowerPoint presentations, which is great if you like PowerPoint (or you are forced to use it), because it gives you access to a lot of its features (like tables, charts, slide notes) for free. On the other hand, this also means that you are limited by what can PowerPoint do. Creating complex fragment animations, pretty syntax highlighted source code snippets or LaTeX equations will probably be nigh impossible using this library. FAQ # Why do you use Inkscape instead of e.g. Cairo for rendering slides? We are experimenting with a Cairo backend, but it would be probably difficult to fully support embedding SVG images into slides with Cairo, which is something that we use a lot. But it is possible that Elsie will not require Inkscape sometime in the future. Why don't you use an existing layout model, e.g. flexbox ? We made the layout model tailored for presentations, which might not be so easy with a general layout model. We also couldn't find any usable binding of a standalone and sane layout model in Python. If you know of any, please let us know . License # MIT . Created by Stanislav B\u00f6hm and Jakub Ber\u00e1nek .","title":"Overview"},{"location":"#elsie","text":"Elsie allows you to create slides programmatically using Python. It is a Python library that lets you build SVG slides in a composable way and then render them to PDF. There is no DSL or GUI \u2013 presentations created with Elsie are fully programmed with Python. It was created out of frustration of having to deal with existing tools for creating technically oriented presentations. We believe that creating presentations in a programmable way makes the slide-making process more smooth and reliable. Quick links Installation Getting started User guide Gallery API Reference","title":"Elsie"},{"location":"#elsie-example","text":"import elsie slides = elsie.SlideDeck() @slides.slide() def hello_world(slide): import datetime slide.box().text(f\"Hello from\") year = str(datetime.datetime.now().year) row = slide.box(horizontal=True, p_top=20) for i in range(4): row.box(width=40, height=40).rect( color=\"black\", bg_color=\"black\" if i % 2 == 0 else \"white\" ).text(year[i], elsie.TextStyle(color=\"red\")) slides.render(\"slides.pdf\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Elsie example"},{"location":"#features","text":"Layout model Elsie provides a simple, yet powerful layout model. Rows, columns, padding, text alignment, relative/absolute positioning and many other layout features are included. Animations and fragments Reveal your slides gradually using fragments and build complex step-by-step animations in Python. Or draw a fine-tuned SVG image by hand e.g. in Inkscape and let Elsie turn it into an animation using a handy layer-naming convention . Source code highlighting Enjoy beautiful code snippets thanks to built-in source code highlighting . Create code walkthroughs using individual line highlighting or arrows pointing to specific code elements. Batteries included Leverage familiar SVG features - fonts, colors, dashed line borders. Include PNG/JPG/SVG/ORA images or render Markdown or LaTeX directly into your slides. Build your slides interactively in Jupyter notebooks . Familiarity At its heart, Elsie is a streamlined API for creating SVG images, optimized for making presentations. If you know the basics of Python and SVG, you'll be right at home. The ultimate feature of Elsie is that it allows you to build slides using (an imperative) programming language. You can split a large presentation into several modules/files, parametrize animations or objects that appear often using functions, create arbitrarily complex slides and animations or interactively modify the font, aspect ratio or text color/size of your whole presentation by changing a single line of code. Every tool has its disadvantages though. Elsie provides a rather low-level API. While that means that you can create a slide in almost any way you like, you will sometimes have to roll up your sleeves to achieve your desired goal. However, once you implement it, you can put it inside a function and reuse it the next time, or send us a Pull Request to share the functionality with others. Elsie produces PDF slides, so it can only create animations with a single frame per page. If you need 60 FPS animations or GIFs in your presentations, this tool is not for you. Elsie currently renders SVG slides to PDF using Inkscape . Therefore, you must have it installed on your system for it to work. We provide a Docker image with Inkscape for convenience. Elsie is tested only on Linux. If you find a problem on a different platform, do not hesitate to open a GitHub issue .","title":"Features"},{"location":"#comparison-to-other-tools","text":"Google slides/PowerPoint These tools are fine if you need to make a bunch of very simple slides quickly, but using them gets very annoying if you need anything more complex. You need to place all items manually, alignment is usually a mess, fragments (animations) are not supported very well. If you need to change some small detail (placement, style, color) of a thing that is repeated on many slides, you pretty much have to go through all the slides and modify them by hand, one by one. Displaying source code with syntax highlighting is notoriously badly supported, so often you have to resort to exporting the highlighted code from carbon.sh or screenshotting it from your IDE, both of which are far from ideal. Also, you can't really use source control (e.g. git ) to version your slides, which is a shame. However, PowerPoint does allow you to create continuous animations (if you do not export to PDF of course), so if you need that, it might be a good choice. It also has a myriad of other useful features, like tables, charts, shared templates, spell checking, etc. LaTeX/Beamer LaTeX has a template called Beamer , which is designed for creating presentation slides. It produces fine-looking text, has good support for syntax highlighting and can be versioned easily. However, in our experience it is not that easy to create custom diagrams and animations using LaTeX, mainly because of its declarative nature (and somewhat confusing syntax). If you can speak fluently in TikZ and you can understand the error messages of pdflatex , you are probably fine. If not, creating slides with complex animations, diagrams and source code snippets might be easier for you in Python. While Elsie also has basic support for rendering LaTeX , if your presentation is mostly composed of math formulas, it might be easier to create it in LaTeX directly. Reveal.js reveal.js is a great tool for making HTML presentations. It supports syntax highlighting, has good-looking animations and can be versioned. However, it shares some disadvantages of LaTeX/Beamer, which stems from the fact that it is also declarative. Creating an animation that would walk line-by-line through a source code snippet or that would repeatedly display and hide objects in custom fragments is difficult. You can actually use JavaScript to create more complex animations, but it's not integrated very well, and the library itself does not offer you any API to make it easier. That being said, if you are fine with declarative description of slides, and you prefer HTML/CSS to Python/SVG, reveal.js is a fine choice. Prezi If you like presentations with three or more dimensions, it's a good choice. Otherwise, the disadvantages of PowerPoint also apply here. python-pptx python-pptx is an API for building PowerPoint presentations, which is great if you like PowerPoint (or you are forced to use it), because it gives you access to a lot of its features (like tables, charts, slide notes) for free. On the other hand, this also means that you are limited by what can PowerPoint do. Creating complex fragment animations, pretty syntax highlighted source code snippets or LaTeX equations will probably be nigh impossible using this library.","title":"Comparison to other tools"},{"location":"#faq","text":"Why do you use Inkscape instead of e.g. Cairo for rendering slides? We are experimenting with a Cairo backend, but it would be probably difficult to fully support embedding SVG images into slides with Cairo, which is something that we use a lot. But it is possible that Elsie will not require Inkscape sometime in the future. Why don't you use an existing layout model, e.g. flexbox ? We made the layout model tailored for presentations, which might not be so easy with a general layout model. We also couldn't find any usable binding of a standalone and sane layout model in Python. If you know of any, please let us know .","title":"FAQ"},{"location":"#license","text":"MIT . Created by Stanislav B\u00f6hm and Jakub Ber\u00e1nek .","title":"License"},{"location":"gallery/","text":"Gallery # Here you can find selected presentations made with Elsie , along with their source codes. If you want to add your own presentation to the gallery, send us a PR ! Elsie demo slides # In this presentation you can find an overview of all the features that Elsie offers. PDF Source Rust # Presentation about basic Rust features. Contains a lot of code snippets, syntax highlighting and code line stepping. PDF Source CPU architecture effects # Presentation about CPU (micro)-architecture effects. Contains advanced animations and source code snippets. PDF Source State-Space Reduction of Non-deterministically Synchronizing Systems Applicable to Deadlock Detection in MPI # Presentation about detecting deadlocks in MPI programs. Contains advanced diagrams. PDF Source","title":"Gallery"},{"location":"gallery/#gallery","text":"Here you can find selected presentations made with Elsie , along with their source codes. If you want to add your own presentation to the gallery, send us a PR !","title":"Gallery"},{"location":"gallery/#elsie-demo-slides","text":"In this presentation you can find an overview of all the features that Elsie offers. PDF Source","title":"Elsie demo slides"},{"location":"gallery/#rust","text":"Presentation about basic Rust features. Contains a lot of code snippets, syntax highlighting and code line stepping. PDF Source","title":"Rust"},{"location":"gallery/#cpu-architecture-effects","text":"Presentation about CPU (micro)-architecture effects. Contains advanced animations and source code snippets. PDF Source","title":"CPU architecture effects"},{"location":"gallery/#state-space-reduction-of-non-deterministically-synchronizing-systems-applicable-to-deadlock-detection-in-mpi","text":"Presentation about detecting deadlocks in MPI programs. Contains advanced diagrams. PDF Source","title":"State-Space Reduction of Non-deterministically Synchronizing Systems Applicable to Deadlock Detection in MPI"},{"location":"getting_started/","text":"Getting started # This is a short tutorial that explains the basic of using Elsie and links to the user guide, which explains individual concepts in more detail. Creating a slide deck # To build a presentation with Elsie , you first have to import it and create an instance of a SlideDeck : import elsie slides = elsie.SlideDeck() SlideDeck is used to add slides to your presentation and also to render the slides to PDF at the end. You can find more about if here . Adding slides # The easiest way of adding slides to the slide deck is to create a function for each slide and mark it with the slide decorator: @slides.slide() def slide1(slide): # ... Each decorated function will receive a slide as its parameter. It should then fill the slide with the desired content. Adding slide content # You can add various things to slides, like text , images , source code , shapes , etc. Each item added to a slide needs to be inside a Box which will decide its layout. You can create a new box by calling the box method on a slide. Inside a box you can then e.g. write some text and apply a style to it: @slides.slide() def slide1(slide): slide.box().text(\"Hello world\") slide.box().text(\"This slide was created by Elsie\", style=elsie.TextStyle(bold=True)) By default, multiple boxes will be stacked below one another and horizontally centered. You can change these properties by modifying the box properties . Elsie has built-in support for fragments, which means that you can easily reveal individual boxes gradually, using the show parameter: @slides.slide() def slide2(slide): slide.box(show=\"1-2\").text(\"I am shown in fragments 1 and 2\") slide.box(show=\"2+\").text(\"I am shown in fragment 2 and 3\") slide.box(show=\"3\").text(\"I am shown in fragment 3\") You can find more about revealing here . Rendering slides # After you build all slides of your presentation, call the render method to build the resulting PDF file: slides.render(\"slides.pdf\") You can also e.g. return a list of slides in raw SVG form or postprocess all slides. See more details about rendering slides here . You can check the user guide or the cookbook to find more detailed guides about individual concepts present in Elsie . For completeness, here is the full code that was shown in this tutorial: import elsie slides = elsie.SlideDeck() @slides.slide() def slide1(slide): slide.box().text(\"Hello world\") slide.box().text(\"This slide was created by Elsie\", style=elsie.TextStyle(bold=True)) @slides.slide() def slide2(slide): slide.box(show=\"1-2\").text(\"I am shown in fragments 1 and 2\") slide.box(show=\"2+\").text(\"I am shown in fragment 2 and 3\") slide.box(show=\"3\").text(\"I am shown in fragment 3\") slides.render(\"slides.pdf\")","title":"Getting started"},{"location":"getting_started/#getting-started","text":"This is a short tutorial that explains the basic of using Elsie and links to the user guide, which explains individual concepts in more detail.","title":"Getting started"},{"location":"getting_started/#creating-a-slide-deck","text":"To build a presentation with Elsie , you first have to import it and create an instance of a SlideDeck : import elsie slides = elsie.SlideDeck() SlideDeck is used to add slides to your presentation and also to render the slides to PDF at the end. You can find more about if here .","title":"Creating a slide deck"},{"location":"getting_started/#adding-slides","text":"The easiest way of adding slides to the slide deck is to create a function for each slide and mark it with the slide decorator: @slides.slide() def slide1(slide): # ... Each decorated function will receive a slide as its parameter. It should then fill the slide with the desired content.","title":"Adding slides"},{"location":"getting_started/#adding-slide-content","text":"You can add various things to slides, like text , images , source code , shapes , etc. Each item added to a slide needs to be inside a Box which will decide its layout. You can create a new box by calling the box method on a slide. Inside a box you can then e.g. write some text and apply a style to it: @slides.slide() def slide1(slide): slide.box().text(\"Hello world\") slide.box().text(\"This slide was created by Elsie\", style=elsie.TextStyle(bold=True)) By default, multiple boxes will be stacked below one another and horizontally centered. You can change these properties by modifying the box properties . Elsie has built-in support for fragments, which means that you can easily reveal individual boxes gradually, using the show parameter: @slides.slide() def slide2(slide): slide.box(show=\"1-2\").text(\"I am shown in fragments 1 and 2\") slide.box(show=\"2+\").text(\"I am shown in fragment 2 and 3\") slide.box(show=\"3\").text(\"I am shown in fragment 3\") You can find more about revealing here .","title":"Adding slide content"},{"location":"getting_started/#rendering-slides","text":"After you build all slides of your presentation, call the render method to build the resulting PDF file: slides.render(\"slides.pdf\") You can also e.g. return a list of slides in raw SVG form or postprocess all slides. See more details about rendering slides here . You can check the user guide or the cookbook to find more detailed guides about individual concepts present in Elsie . For completeness, here is the full code that was shown in this tutorial: import elsie slides = elsie.SlideDeck() @slides.slide() def slide1(slide): slide.box().text(\"Hello world\") slide.box().text(\"This slide was created by Elsie\", style=elsie.TextStyle(bold=True)) @slides.slide() def slide2(slide): slide.box(show=\"1-2\").text(\"I am shown in fragments 1 and 2\") slide.box(show=\"2+\").text(\"I am shown in fragment 2 and 3\") slide.box(show=\"3\").text(\"I am shown in fragment 3\") slides.render(\"slides.pdf\")","title":"Rendering slides"},{"location":"installation/","text":"Installation # Requirements # Python 3.6+ Inkscape 1.0+ Versions under 1.0 and above 0.92 might also work, but they are not primarily supported (Required only for LaTeX support): pdflatex , pdf2svg Native installation # You can install Elsie using PyPi : $ pip3 install elsie You will also need Inkscape installed, preferably with version 1.0+. You can find how to install Inkscape here . On Ubuntu you can simply execute $ apt-get install inkscape Docker installation # We also provide a Docker image that has Inkscape and all the required Python dependencies installed. First build the image: $ docker build -t elsie . After that you can use it to render your slides. Let's assume that you have a file called slides.py in the current directory and you want to render it into PDF. You can do that with the following command: $ docker run --rm \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ -v${PWD}:/slides \\ elsie python3 /slides/slides.py The slides should then appear in your current directory (by default in slides.pdf ).","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#requirements","text":"Python 3.6+ Inkscape 1.0+ Versions under 1.0 and above 0.92 might also work, but they are not primarily supported (Required only for LaTeX support): pdflatex , pdf2svg","title":"Requirements"},{"location":"installation/#native-installation","text":"You can install Elsie using PyPi : $ pip3 install elsie You will also need Inkscape installed, preferably with version 1.0+. You can find how to install Inkscape here . On Ubuntu you can simply execute $ apt-get install inkscape","title":"Native installation"},{"location":"installation/#docker-installation","text":"We also provide a Docker image that has Inkscape and all the required Python dependencies installed. First build the image: $ docker build -t elsie . After that you can use it to render your slides. Let's assume that you have a file called slides.py in the current directory and you want to render it into PDF. You can do that with the following command: $ docker run --rm \\ -u $(id -u ${USER}):$(id -g ${USER}) \\ -v${PWD}:/slides \\ elsie python3 /slides/slides.py The slides should then appear in your current directory (by default in slides.pdf ).","title":"Docker installation"},{"location":"cookbook/codestepping/","text":"Code stepping # Elsie makes it easy to create interactive walkthroughs of code snippets. You can e.g. highlight each line in succession, show arrows pointing to different lines or gradually reveal the snippet line-by-line. For inspiration, here we show a function that will take a code snippet and display selected lines from it in successive fragments, according to the passed line_fragments parameter. def code_step(parent: Box, code: str, language: str, line_fragments, **code_args): # Split the code into lines code = code.strip() lines = code.split(\"\\n\") # Return either a line with the given index or an empty line def get_line(lines, visible): if visible is None: return \"\" elif isinstance(visible, int): return lines[visible] last = None for (step, visible_lines) in enumerate(line_fragments): # Overlay the whole parent box at each step wrapper = parent.overlay(show=str(step + 1)) current_lines = [get_line(lines, visible) for visible in visible_lines] last = wrapper.code(language, \"\\n\".join(current_lines), **code_args) return last code_step(slide.box(width=200, height=200), \"\"\" def my_abs(x): if x < 0: x = -x assert x >= 0 \"\"\", \"python\", ( [0, None, None, 3], # Show only the first and last line [0, 1, None, 3], # Show first two lines and the last line [0, 1, 2, 3] # Show all lines )) < Fragment: 1 > (function () { var active_step = 1; var max_step = 3; var slide_id = \".elsie-wrapper-4882444a1c334c5e9efb306c1d1f1d2a\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Code stepping"},{"location":"cookbook/codestepping/#code-stepping","text":"Elsie makes it easy to create interactive walkthroughs of code snippets. You can e.g. highlight each line in succession, show arrows pointing to different lines or gradually reveal the snippet line-by-line. For inspiration, here we show a function that will take a code snippet and display selected lines from it in successive fragments, according to the passed line_fragments parameter. def code_step(parent: Box, code: str, language: str, line_fragments, **code_args): # Split the code into lines code = code.strip() lines = code.split(\"\\n\") # Return either a line with the given index or an empty line def get_line(lines, visible): if visible is None: return \"\" elif isinstance(visible, int): return lines[visible] last = None for (step, visible_lines) in enumerate(line_fragments): # Overlay the whole parent box at each step wrapper = parent.overlay(show=str(step + 1)) current_lines = [get_line(lines, visible) for visible in visible_lines] last = wrapper.code(language, \"\\n\".join(current_lines), **code_args) return last code_step(slide.box(width=200, height=200), \"\"\" def my_abs(x): if x < 0: x = -x assert x >= 0 \"\"\", \"python\", ( [0, None, None, 3], # Show only the first and last line [0, 1, None, 3], # Show first two lines and the last line [0, 1, 2, 3] # Show all lines )) < Fragment: 1 > (function () { var active_step = 1; var max_step = 3; var slide_id = \".elsie-wrapper-4882444a1c334c5e9efb306c1d1f1d2a\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Code stepping"},{"location":"cookbook/grids/","text":"Grids # The box model of Elsie makes it easy to create fixed size rectangular grids. Simply create a box with a horizontal layout for each row and then fill it with a fixed-size box for each column. If you need spaces between the grid items, you can put padding on the inner boxes. row_count = 2 column_count = 3 for r in range(row_count): row = slide.box(horizontal=True, p_bottom=10) for c in range(column_count): color = \"#FF2400\" if c % 2 == 0 else \"#16A085\" box = row.box(width=100, height=100, p_right=10) box.rect(color=\"black\", bg_color=color) box.text(f\"({r}, {c})\", elsie.TextStyle(color=\"white\")) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Using fragments , you can then make the grid items appear gradually: row_count = 2 column_count = 3 fragment = 1 for r in range(row_count): row = slide.box(horizontal=True, p_bottom=10) for c in range(column_count): box = row.box(width=100, height=100, p_right=10, show=f\"{fragment}+\") box.rect(color=\"black\") box.text(f\"({r}, {c})\") fragment += 1 < Fragment: 1 > (function () { var active_step = 1; var max_step = 6; var slide_id = \".elsie-wrapper-e9a6b71d4bdf413ebf490d10da0cd1d0\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Grids"},{"location":"cookbook/grids/#grids","text":"The box model of Elsie makes it easy to create fixed size rectangular grids. Simply create a box with a horizontal layout for each row and then fill it with a fixed-size box for each column. If you need spaces between the grid items, you can put padding on the inner boxes. row_count = 2 column_count = 3 for r in range(row_count): row = slide.box(horizontal=True, p_bottom=10) for c in range(column_count): color = \"#FF2400\" if c % 2 == 0 else \"#16A085\" box = row.box(width=100, height=100, p_right=10) box.rect(color=\"black\", bg_color=color) box.text(f\"({r}, {c})\", elsie.TextStyle(color=\"white\")) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Using fragments , you can then make the grid items appear gradually: row_count = 2 column_count = 3 fragment = 1 for r in range(row_count): row = slide.box(horizontal=True, p_bottom=10) for c in range(column_count): box = row.box(width=100, height=100, p_right=10, show=f\"{fragment}+\") box.rect(color=\"black\") box.text(f\"({r}, {c})\") fragment += 1 < Fragment: 1 > (function () { var active_step = 1; var max_step = 6; var slide_id = \".elsie-wrapper-e9a6b71d4bdf413ebf490d10da0cd1d0\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Grids"},{"location":"cookbook/headers/","text":"Headers and footers # It is quite common to use a unified header and/or footer for all slides of a slide deck. You can achieve this using Elsie e.g. by creating a factory function for each slide: def init_slide(slide, header_text: str): # Create a header with some background color header = slide.box(width=\"fill\", height=\"10%\").rect(bg_color=\"#23363A\") # Put some text into the header header.box(x=10, padding=10).text(header_text, style=elsie.TextStyle( size=30, bold=True, color=\"#FFFFFF\" )) # Return the remaining content of the slide return slide.fbox() And then calling this function on each slide to give it a header. @slides.slide() def slide1(slide): content = init_slide(slide, \"Welcome\") content.text(\"Welcome to my presentation\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } @slides.slide() def slide2(slide): content = init_slide(slide, \"Outline\") content.text(\"Here is the outline of my presentation\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Headers and footers"},{"location":"cookbook/headers/#headers-and-footers","text":"It is quite common to use a unified header and/or footer for all slides of a slide deck. You can achieve this using Elsie e.g. by creating a factory function for each slide: def init_slide(slide, header_text: str): # Create a header with some background color header = slide.box(width=\"fill\", height=\"10%\").rect(bg_color=\"#23363A\") # Put some text into the header header.box(x=10, padding=10).text(header_text, style=elsie.TextStyle( size=30, bold=True, color=\"#FFFFFF\" )) # Return the remaining content of the slide return slide.fbox() And then calling this function on each slide to give it a header. @slides.slide() def slide1(slide): content = init_slide(slide, \"Welcome\") content.text(\"Welcome to my presentation\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } @slides.slide() def slide2(slide): content = init_slide(slide, \"Outline\") content.text(\"Here is the outline of my presentation\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Headers and footers"},{"location":"cookbook/postprocessing/","text":"Slide postprocessing # Sometimes you may want to add some global data to your slides, for example a footer, license information or slide numbers . To make it easier, you can pass a function to the slide_postprocessing parameter of the render method. The function will receive a list of root boxes of each slide in the presentation. You can then go through the list and modify the slides, for example by adding some text to them. Slide numbering # It is quite easy to add numbers to each slide using slide postprocessing. Here is an example: import elsie slides = elsie.SlideDeck() @slides.slide() def slide1(slide): slide.text(\"Page numbering demo\") @slides.slide() def slide2(slide): slide.box().text(\"Hello world!\") slide.box(show=\"next+\").text(\"Hello world!\") slide.box(show=\"next+\").text(\"Hello world!\") @slides.slide() def slide3(slide): slide.box().text(\"Last slide\") def page_numbering(slides): for i, slide in enumerate(slides): slide.box(x=\"90%\", y=\"90%\", width=70, height=45).rect( bg_color=\"orange\", rx=5, ry=5 ).text(f\"{i + 1}/{len(slides)}\") slides.render(slide_postprocessing=page_numbering) You can find the rendered PDF with slide numbers here . You could also easily create a fragment number for each fragment of each slide by iterating numbers up to the current_fragment() of each slide.","title":"Slide postprocessing"},{"location":"cookbook/postprocessing/#slide-postprocessing","text":"Sometimes you may want to add some global data to your slides, for example a footer, license information or slide numbers . To make it easier, you can pass a function to the slide_postprocessing parameter of the render method. The function will receive a list of root boxes of each slide in the presentation. You can then go through the list and modify the slides, for example by adding some text to them.","title":"Slide postprocessing"},{"location":"cookbook/postprocessing/#slide-numbering","text":"It is quite easy to add numbers to each slide using slide postprocessing. Here is an example: import elsie slides = elsie.SlideDeck() @slides.slide() def slide1(slide): slide.text(\"Page numbering demo\") @slides.slide() def slide2(slide): slide.box().text(\"Hello world!\") slide.box(show=\"next+\").text(\"Hello world!\") slide.box(show=\"next+\").text(\"Hello world!\") @slides.slide() def slide3(slide): slide.box().text(\"Last slide\") def page_numbering(slides): for i, slide in enumerate(slides): slide.box(x=\"90%\", y=\"90%\", width=70, height=45).rect( bg_color=\"orange\", rx=5, ry=5 ).text(f\"{i + 1}/{len(slides)}\") slides.render(slide_postprocessing=page_numbering) You can find the rendered PDF with slide numbers here . You could also easily create a fragment number for each fragment of each slide by iterating numbers up to the current_fragment() of each slide.","title":"Slide numbering"},{"location":"cookbook/zoom/","text":"Zooming # SVG defines a viewbox attribute, which allows you to change from which view point is the SVG image rendered. Elsie also supports this attribute via the view_box parameter. Using a specific viewbox, you can for example create \"zoomed\" slides. This might be useful if you first want to show an overview of something and then later zoom-in to show some details. Let's create a function that will render some content: def render_slide(parent): parent.box(x=50, y=50, width=100, height=80).rect(bg_color=\"red\") return parent.box(x=180, y=50, width=80, height=80).ellipse(bg_color=\"blue\") Now we can use it to create an overview slide: @slides.slide() def overview(slide): render_slide(slide) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } And then render the slide content again, this time zoomed-in on a particular spot: @slides.slide(view_box=(120, 80, 80, 30)) def detail(slide): circle = render_slide(slide) # Text label textbox = slide.box(x=130, y=80, z_level=2) textbox.overlay(z_level=1).rect(bg_color=\"yellow\") textbox.box(padding=1).text(\"Circle edge\", elsie.TextStyle(size=6)) # Line with arrow slide.box().line([ textbox.p(\"100%\", \"50%\"), circle.p(\"0%\", \"50%\") ], end_arrow=elsie.Arrow(size=6)) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Zooming"},{"location":"cookbook/zoom/#zooming","text":"SVG defines a viewbox attribute, which allows you to change from which view point is the SVG image rendered. Elsie also supports this attribute via the view_box parameter. Using a specific viewbox, you can for example create \"zoomed\" slides. This might be useful if you first want to show an overview of something and then later zoom-in to show some details. Let's create a function that will render some content: def render_slide(parent): parent.box(x=50, y=50, width=100, height=80).rect(bg_color=\"red\") return parent.box(x=180, y=50, width=80, height=80).ellipse(bg_color=\"blue\") Now we can use it to create an overview slide: @slides.slide() def overview(slide): render_slide(slide) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } And then render the slide content again, this time zoomed-in on a particular spot: @slides.slide(view_box=(120, 80, 80, 30)) def detail(slide): circle = render_slide(slide) # Text label textbox = slide.box(x=130, y=80, z_level=2) textbox.overlay(z_level=1).rect(bg_color=\"yellow\") textbox.box(padding=1).text(\"Circle edge\", elsie.TextStyle(size=6)) # Line with arrow slide.box().line([ textbox.p(\"100%\", \"50%\"), circle.p(\"0%\", \"50%\") ], end_arrow=elsie.Arrow(size=6)) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Zooming"},{"location":"userguide/basics/","text":"Basics # A presentation (set of slides) is represented in Elsie with the SlideDeck class. The most important parameters of the presentation is the width and height of the resulting PDF pages, which also affects the resulting aspect ratio. The default size if 1024x768 , which corresponds to aspect ratio 4:3 . Here is an example of creating a new presentation: import elsie slides = elsie.SlideDeck(width=1024, height=768) Once you have a SlideDeck object, you can create new slides from it. Creating slides # You can create new slides in two ways, either using the new_slide method or via a decorator . The new_slide method will create a new slide, but for convenience, it will not return the slide itself, but its root box , so that you can use the returned object immediately for adding things to the slide. Except for some advanced usage, you shouldn't ever need to deal with the Slide instance itself. slide = slides.new_slide(bg_color=\"blue\") Once you have a slide, you can add content to it, for example text , images , shapes or source code . Decorator # A more convenient way of creating a slide is using the slide decorator. If you apply it to a function, it will create a new slide and pass its root box as a parameter to the function. It will also set the name of the slide according to the name of the decorated function. @slides.slide() def slide1(slide: elsie.Box): slide.box().text(\"Hello\") With this approach, the slide will be added to the slide deck immediately when you use the decorator. Therefore, you should not call the decorated function manually. The order of the slides will be the same as in the source code: @slides.slide() def slide1(slide): slide.text(\"Slide 1\") @slides.slide() def slide2(slide): slide.text(\"Slide 2\") You can also combine the decorator and new_slide , although this is mostly discouraged, as it get be confusing to follow the order of the slides. Both slide and new_slide have parameters that allow you to change the background color and SVG viewbox of the slide (see example usage here ). You can also choose its name (see below ) or enable debug draw mode . Rendering slides # After you have created all of your desired slides and filled them with content, you can render your presentation using the render method. There are several useful parameters of this method: output : Change the output filename of the rendered PDF (default is slides.pdf ). slide_postprocessing : Apply some postprocessing function to all slides. See an example here . select_slides : Render only a selected subset of slides. return_units : Return a list of SVG slides without rendering them. This can be useful if you just want to build your slides using Elsie , but render them in a another way. slider_per_page(x, y) : Group several slides into a single page. Each page will contain a grid of slides with x rows and y columns. This can be useful e.g. for creating presentation previews. Elsie uses caching to speed-up the rendering. The cache will be created in a directory named elsie-cache . Name policy # If you create slides in an interactive Python session (for example in IPython or Jupyter ), you might inadvertedly create new slides after modifying and re-executing a piece of code. For example, if this code was inside a Jupyter notebook cell: @slides.slide() def slide1(slide): slide.box().text(\"Hello\") Each time you would execute the cell, a new slide would be added to the presentation, which is probably not what you want. To solve this issue, Elsie contains a so-called name policy , which decides how to react to the situation where the same slide is created repeatedly. SlideDeck are identified by their name, which you either pass to new_slide or it is determined automatically if the decorator is used. The SlideDeck instance has one of the following name policies, which decides what to do when a new slide is created: unique : Creating two slides with the same name will result in an error. This is to stop you from creating multiple instances of the same slide inadvertedly. Note that when a name of a slide is unset (it is None ), the slide will be allowed to be created. replace : When a slide with the same name already exists, the previous slide will be removed, and the new slide will be placed at the end of the slide list. ignore : The name of slides will not be checked, essentially turns off name policy. auto (the default): Uses replace when running inside Jupyter, otherwise uses unique . Since Jupyter automatically sets a name policy which is most probably the one that you want in an interactive environment ( replace ), you will not have to deal with name policy most of the time.","title":"Basics"},{"location":"userguide/basics/#basics","text":"A presentation (set of slides) is represented in Elsie with the SlideDeck class. The most important parameters of the presentation is the width and height of the resulting PDF pages, which also affects the resulting aspect ratio. The default size if 1024x768 , which corresponds to aspect ratio 4:3 . Here is an example of creating a new presentation: import elsie slides = elsie.SlideDeck(width=1024, height=768) Once you have a SlideDeck object, you can create new slides from it.","title":"Basics"},{"location":"userguide/basics/#creating-slides","text":"You can create new slides in two ways, either using the new_slide method or via a decorator . The new_slide method will create a new slide, but for convenience, it will not return the slide itself, but its root box , so that you can use the returned object immediately for adding things to the slide. Except for some advanced usage, you shouldn't ever need to deal with the Slide instance itself. slide = slides.new_slide(bg_color=\"blue\") Once you have a slide, you can add content to it, for example text , images , shapes or source code .","title":"Creating slides"},{"location":"userguide/basics/#decorator","text":"A more convenient way of creating a slide is using the slide decorator. If you apply it to a function, it will create a new slide and pass its root box as a parameter to the function. It will also set the name of the slide according to the name of the decorated function. @slides.slide() def slide1(slide: elsie.Box): slide.box().text(\"Hello\") With this approach, the slide will be added to the slide deck immediately when you use the decorator. Therefore, you should not call the decorated function manually. The order of the slides will be the same as in the source code: @slides.slide() def slide1(slide): slide.text(\"Slide 1\") @slides.slide() def slide2(slide): slide.text(\"Slide 2\") You can also combine the decorator and new_slide , although this is mostly discouraged, as it get be confusing to follow the order of the slides. Both slide and new_slide have parameters that allow you to change the background color and SVG viewbox of the slide (see example usage here ). You can also choose its name (see below ) or enable debug draw mode .","title":"Decorator"},{"location":"userguide/basics/#rendering-slides","text":"After you have created all of your desired slides and filled them with content, you can render your presentation using the render method. There are several useful parameters of this method: output : Change the output filename of the rendered PDF (default is slides.pdf ). slide_postprocessing : Apply some postprocessing function to all slides. See an example here . select_slides : Render only a selected subset of slides. return_units : Return a list of SVG slides without rendering them. This can be useful if you just want to build your slides using Elsie , but render them in a another way. slider_per_page(x, y) : Group several slides into a single page. Each page will contain a grid of slides with x rows and y columns. This can be useful e.g. for creating presentation previews. Elsie uses caching to speed-up the rendering. The cache will be created in a directory named elsie-cache .","title":"Rendering slides"},{"location":"userguide/basics/#name-policy","text":"If you create slides in an interactive Python session (for example in IPython or Jupyter ), you might inadvertedly create new slides after modifying and re-executing a piece of code. For example, if this code was inside a Jupyter notebook cell: @slides.slide() def slide1(slide): slide.box().text(\"Hello\") Each time you would execute the cell, a new slide would be added to the presentation, which is probably not what you want. To solve this issue, Elsie contains a so-called name policy , which decides how to react to the situation where the same slide is created repeatedly. SlideDeck are identified by their name, which you either pass to new_slide or it is determined automatically if the decorator is used. The SlideDeck instance has one of the following name policies, which decides what to do when a new slide is created: unique : Creating two slides with the same name will result in an error. This is to stop you from creating multiple instances of the same slide inadvertedly. Note that when a name of a slide is unset (it is None ), the slide will be allowed to be created. replace : When a slide with the same name already exists, the previous slide will be removed, and the new slide will be placed at the end of the slide list. ignore : The name of slides will not be checked, essentially turns off name policy. auto (the default): Uses replace when running inside Jupyter, otherwise uses unique . Since Jupyter automatically sets a name policy which is most probably the one that you want in an interactive environment ( replace ), you will not have to deal with name policy most of the time.","title":"Name policy"},{"location":"userguide/images/","text":"Images # Images can be inserted into a slide by calling the image method on a box. The first parameter is the path to the image. slide.image(\"imgs/python.png\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } By default, the image tries to maximally fit into its containing box without changing the aspect ratio. Image scale can be set explicitly with the scale parameter. slide.image(\"imgs/python.png\", scale=0.2) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can also rotate images using the rotation parameter. Pass it an angle in degrees to rotate the image clockwise around its center. slide.image(\"imgs/python.png\", rotation=180) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Elsie supports the following image formats: SVG, PNG, JPEG, and ORA (Open Raster Format). You can also pass a binary image to the image method (for example bytes or BinaryIO ) instead of a file path. In that case you have to specify the image_type of the image. Embedding fragments in images # Sometimes you may want to create slides manually in e.g. Inkscape, for example if the slide is drawn by hand or if it contains many finely-tuned objects. Using these manually created slides in Elsie is easy, you can just export them from Inkscape and include them in a box using the image method. However, if you want to create animations using this manual approach, it gets quickly pretty tedious to export all the fragments of the animation one by one and then include them in Elsie , especially if you are modifying the animation interactively. For that reason Elsie allows you to create an animation from a single SVG or ORA file. If you name a layer (SVG/ORA) or a label of an element (SVG only) in the following way: <name>**<annotation> , the annotation part will be interpreted by Elsie as a value for the show parameter of a box. Using this convention, you can assign fragments to individual elements inside a single SVG or ORA image and thus create an animation from a single file. Note that fragment placeholders are not allowed in this context. Here are some examples of how it works: SVG layer/element named Foo **2+ will only be shown in fragments 2 and further. SVG layer/element named Bar **3-5 will only be shown in fragments 3 , 4 and 5 . All elements that do not use the ** -suffixed name will be interpreted as having show=\"1+\" . You can further control how fragments of an image will be displayed using the following parameters of the image method: fragments=False : Fragment annotations will be ignored. show_begin=<x> : Shifts all fragments in the image forward so that x will be the first fragment from the perspective of the image. This will cause the image to appear at fragment x , a layer named Foo**2 would appear at fragment x + 1 , etc. select_fragments=<list> (each element of the list is either an integer or None ): This parameter allows you to completely rearrange the fragments of the image. For example, [3, 7, None, 3] would show: In the 1st slide fragment: the 3rd image fragment In the 2nd slide fragment: the 7th image fragment In the 3rd slide fragment: no image fragment In the 4rd slide fragment: again the 3rd image fragment","title":"Images"},{"location":"userguide/images/#images","text":"Images can be inserted into a slide by calling the image method on a box. The first parameter is the path to the image. slide.image(\"imgs/python.png\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } By default, the image tries to maximally fit into its containing box without changing the aspect ratio. Image scale can be set explicitly with the scale parameter. slide.image(\"imgs/python.png\", scale=0.2) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can also rotate images using the rotation parameter. Pass it an angle in degrees to rotate the image clockwise around its center. slide.image(\"imgs/python.png\", rotation=180) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Elsie supports the following image formats: SVG, PNG, JPEG, and ORA (Open Raster Format). You can also pass a binary image to the image method (for example bytes or BinaryIO ) instead of a file path. In that case you have to specify the image_type of the image.","title":"Images"},{"location":"userguide/images/#embedding-fragments-in-images","text":"Sometimes you may want to create slides manually in e.g. Inkscape, for example if the slide is drawn by hand or if it contains many finely-tuned objects. Using these manually created slides in Elsie is easy, you can just export them from Inkscape and include them in a box using the image method. However, if you want to create animations using this manual approach, it gets quickly pretty tedious to export all the fragments of the animation one by one and then include them in Elsie , especially if you are modifying the animation interactively. For that reason Elsie allows you to create an animation from a single SVG or ORA file. If you name a layer (SVG/ORA) or a label of an element (SVG only) in the following way: <name>**<annotation> , the annotation part will be interpreted by Elsie as a value for the show parameter of a box. Using this convention, you can assign fragments to individual elements inside a single SVG or ORA image and thus create an animation from a single file. Note that fragment placeholders are not allowed in this context. Here are some examples of how it works: SVG layer/element named Foo **2+ will only be shown in fragments 2 and further. SVG layer/element named Bar **3-5 will only be shown in fragments 3 , 4 and 5 . All elements that do not use the ** -suffixed name will be interpreted as having show=\"1+\" . You can further control how fragments of an image will be displayed using the following parameters of the image method: fragments=False : Fragment annotations will be ignored. show_begin=<x> : Shifts all fragments in the image forward so that x will be the first fragment from the perspective of the image. This will cause the image to appear at fragment x , a layer named Foo**2 would appear at fragment x + 1 , etc. select_fragments=<list> (each element of the list is either an integer or None ): This parameter allows you to completely rearrange the fragments of the image. For example, [3, 7, None, 3] would show: In the 1st slide fragment: the 3rd image fragment In the 2nd slide fragment: the 7th image fragment In the 3rd slide fragment: no image fragment In the 4rd slide fragment: again the 3rd image fragment","title":"Embedding fragments in images"},{"location":"userguide/jupyter/","text":"Jupyter integration # Elsie has built-in support for creating slides interactively using Jupyter . If you return a box from a Jupyter notebook cell, it will be rendered directly inside the notebook: import elsie slides = elsie.SlideDeck() slide = slides.new_slide() slide.box().text(\"Hello world\") slide If you create slides using the decorator approach, you need to return the decorated function from the cell: import elsie slides = elsie.SlideDeck() @slides.slide() def hello(slide): slide.box().text(\"Hello world\") hello If your slide contains multiple fragments , there will be two buttons below the slide which will let you move between the individual fragments: slide.box().text(\"Box 1\") slide.box(show=\"next+\").text(\"Box 2\") slide < Fragment: 1 > (function () { var active_step = 1; var max_step = 2; var slide_id = \".elsie-wrapper-71af2baeb0534f05b3df1924db9f9495\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } If you use something like ipywidgets , you can create fully interactive slides. For example, you can create something like this: You can see an example of Jupyter integration here . Name policy inside Jupyter # The name policy is automatically set to replace when running inside Jupyter. Therefore, if you re-run a cell which creates a slide with the same name as in the previous cell execution, the previous slide will be removed. Otherwise, you would create a new slide for each execution of a cell, which might not be what you want. To make the process of naming slides easier, we recommend you to create slides using the decorator , which will name them automatically, according to the name of the decorated function. Note that after modifying a cell with a slide when using the replace policy, you should also execute all the following cells with slides to not change the order of slides. In general, creating slides inside Jupyter is designed for interactive experiments with complex slides. For a final render, you should either copy your code into a Python script or restart the notebook kernel and reexecute the whole notebook from the start.","title":"Jupyter integration"},{"location":"userguide/jupyter/#jupyter-integration","text":"Elsie has built-in support for creating slides interactively using Jupyter . If you return a box from a Jupyter notebook cell, it will be rendered directly inside the notebook: import elsie slides = elsie.SlideDeck() slide = slides.new_slide() slide.box().text(\"Hello world\") slide If you create slides using the decorator approach, you need to return the decorated function from the cell: import elsie slides = elsie.SlideDeck() @slides.slide() def hello(slide): slide.box().text(\"Hello world\") hello If your slide contains multiple fragments , there will be two buttons below the slide which will let you move between the individual fragments: slide.box().text(\"Box 1\") slide.box(show=\"next+\").text(\"Box 2\") slide < Fragment: 1 > (function () { var active_step = 1; var max_step = 2; var slide_id = \".elsie-wrapper-71af2baeb0534f05b3df1924db9f9495\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } If you use something like ipywidgets , you can create fully interactive slides. For example, you can create something like this: You can see an example of Jupyter integration here .","title":"Jupyter integration"},{"location":"userguide/jupyter/#name-policy-inside-jupyter","text":"The name policy is automatically set to replace when running inside Jupyter. Therefore, if you re-run a cell which creates a slide with the same name as in the previous cell execution, the previous slide will be removed. Otherwise, you would create a new slide for each execution of a cell, which might not be what you want. To make the process of naming slides easier, we recommend you to create slides using the decorator , which will name them automatically, according to the name of the decorated function. Note that after modifying a cell with a slide when using the replace policy, you should also execute all the following cells with slides to not change the order of slides. In general, creating slides inside Jupyter is designed for interactive experiments with complex slides. For a final render, you should either copy your code into a Python script or restart the notebook kernel and reexecute the whole notebook from the start.","title":"Name policy inside Jupyter"},{"location":"userguide/latex/","text":"Latex # Elsie can render LaTeX directly into your slides. You need to have pdflatex and pdf2svg installed for this to work. LaTeX code can be rendered using the latex function. You can find an example of LaTeX usage with Elsie here .","title":"Latex"},{"location":"userguide/latex/#latex","text":"Elsie can render LaTeX directly into your slides. You need to have pdflatex and pdf2svg installed for this to work. LaTeX code can be rendered using the latex function. You can find an example of LaTeX usage with Elsie here .","title":"Latex"},{"location":"userguide/layout/","text":"Layout # Elsie contains a layout system which allows you to quickly build scenarios that are common in presentations, while still providing the option of finely tuned customization for situations where every pixel placement matters. The central element of the layout system is the Box . Each Elsie slide contains a layout hierarchy tree. The internal nodes of the tree are boxes and the leaves are box items . Boxes are layout containers, which do not produce any visual content, but they dictate how are their children laid out on a slide. Box items are individual paintable items, such as text, images, shapes, etc. Anything that can be rendered by Elsie thus has an accompanied parent box which decides its size and position on a slide. Creating boxes # To create a new box, you can call the box method on an existing Box . This will return a new box which will be a child of the box object on which you call the box method. The root box of the slide layout hierarchy is available to you as the return value of the new_slide method or the slide decorator. Here we create three boxes as children of the top-level slide box and create a child text item in each box. slide.box().text(\"Box 1\") slide.box().text(\"Box 2\") slide.box().text(\"Box 3\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Note: for brevity, most code snippets in this user guide assume that there is a slides variable containing a SlideDeck object and a slide variable containing a Slide object. The render method call is also omitted from most of the examples that display rendered slide output. The output from the code snippets is rendered into PNG images instead of SVG images to ensure that they will be displayed consistently on each device. Debug draw mode # The boxes themselves are invisible, but they have caused the three text items to be rendered below one another. If you are fine-tuning or debugging the layout of your slide, and you want to see the extents and bounds of your boxes, you can use the debug_boxes parameter when creating a slide: @slides.slide(debug_boxes=True) def three_boxes_debug(slide): slide.box().text(\"Box 1\") slide.box().text(\"Box 2\") slide.box().text(\"Box 3\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can see that there is a single root box that wraps the whole slide and then there are three individual boxes in the middle. The box debug draw mode will be used in some examples on this page to demonstrate the extents of individual boxes. Default box layout properties # Newly created boxes have the following behavior by default: They occupy as few space as possible. You can change this by modifying their size . Children are placed vertically in a column, in the order in which they were created. You can change this by modifying their axis . Children are centered vertically and horizontally. You can change this by modifying their position . In the following sections below we will see how these default positioning and sizing rules can be changed. Box naming # Boxes can be named with the name parameter ( .box(name=\"My box\") ). It has no impact on normal rendering of the slide, but the name will be shown if the box debug draw mode is enabled. If you use the @slides.slide() decorator, the name of the top-level slide will be set to the name of the function on which the decorator was used. Box axis # Boxes can either be vertical or horizontal : Vertical boxes place its child items vertically in a column. Their main axis is vertical and their cross axis is horizontal. Horizontal boxes place its child items horizontally in a row. Their main axis is horizontal and their cross axis is vertical. Boxes are vertical by default, if you want to create a horizontal box, use the horizontal=True parameter when creating a box: box = slide.box(horizontal=True) box.box().text(\"Box 1\") box.box().text(\"Box 2\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Composing boxes # By composing boxes, you can create complex hierarchical row and column layouts. row = slide.box(horizontal=True) col_a = row.box() col_a.box().text(\"Col. A/1\") col_a.box().text(\"Col. A/2\") col_b = row.box() col_b.box().text(\"Col. B/1\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Note that almost all methods on a box will create a new box ( box ) or an item (e.g. text or rect ). Leaf items cannot contain children, but for convenience they also offer most of the methods available on boxes, which they delegate to their parent. Therefore, the following two snippets will create the same slide content: # A: create text on its parent box box = slide.box() box.rect(bg_color=\"#aaf\") box.text(\"Hello!\") # B: create text on its sibling rectangle slide.box().rect(bg_color=\"#aaf\").text(\"Hello!\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Sizing boxes # You can change the width and height of a box by using the width and height parameters of the box method. Here we create three boxes ( A , B and C ). Box A has a default size, which is set according to the required size of its text child. Box B has a width of 300 pixels and height of 100 pixels. Box C has width equal to the full width of its parent and height is again set to the height of its child text item. slide.box(name=\"A\").text(\"Box 1\") slide.box(name=\"B\", width=300, height=100).text(\"Box 2\") slide.box(name=\"C\", width=\"100%\").text(\"Box 3\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } The width and height parameters define the minimal size of the box. Therefore, if its children (child boxes, text items, etc.) request a larger size, the box will use the requested size of its content. Size value formats # You can enter width and height values in several formats: None (the default): No minimal size request. int , float or a string containg only digits: Exact minimal size defined in pixels. \"<number>%\" (e.g. \"50%\" ): Minimal size in percentage of the parent box size. \"fill\" or \"fill(<number>)\" : The box will fill all available space of the parent box. If there are more boxes on the same level which use fill, then the size will be distributed amongst them, while respecting the ratio of the fill parameter. For example, when one box has argument fill(2) and the second one fill(3) , the remaining size will be divided using the ratio 2:3 . Using just \"fill\" is a shortcut for \"fill(1)\" . The following code shows an example of \"fill\" usage: slide.box(width=\"fill\").text(\"Box 1\") box = slide.box(width=300, height=180) box.box(height=\"fill(1)\").text(\"Box 2\") box.box(height=\"fill(2)\").text(\"Box 3\") slide.box(height=\"fill\").text(\"Box 4\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Aliases for commonly sized boxes # Elsie contains three shortcuts for creating boxes with common minimal size requirements: fbox (fill-box): shortcut for box(width=\"fill\", height=\"fill\") . sbox (stretch-box): shortcut for box(width=\"fill\") if the parent box has a vertical layout or box(height=\"fill\") if the parent box has a horizontal layout. In other words, it fills the box in the cross axis. overlay : shortcut for box(x=0, y=0, width=\"100%\", height=\"100%) . This can be used if you want to overlay several boxes on top of each other, which is useful especially in combination with revealing . Padding # By default, each box gives all of its space to its children. This can be modified by padding. There are four padding values: left , right , top , and bottom . They can be modified with the p_left , p_right , p_top , and p_bottom parameters of the box method. After the layout of the parent box is computed and the final size and position of a box is known, the padding will shrink its size in the specified directions. slide.box(width=160, height=100, p_left=40, name=\"Top box\") slide.box(width=160, height=150, p_y=50, name=\"Bottom box\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } In the above example, the top box is shrunk by 40 pixels from the left. Note that the padding is applied after the layout was calculated, therefore the box was first centered horizontally, and then the padding reduced its size. The bottom box is shrunk by 50 pixels from the top and from the bottom. You can also use the following padding shortcut parameters of the box method: p_x sets both p_left and p_right . p_y sets both p_top and p_bottom . padding sets all four paddings at once. Positioning boxes # You can set the position of the top-left corner of a box via the x and y parameters of the box method. You can enter the x and y positions in several formats: None (default): Set the default position (see below ). int , float or a string containing only digits: Set absolute position in pixels. Coordinates are relative to the top-left corner of the parent box. \"<number>% : Set position relative to the parent box. \"0%\" represents the left ( x ) or top ( y ) edge of the parent and \"100%\" the right ( x ) or bottom ( y ) edge of the parent. \"[<number>%] : Align the box in the parent box. \"[0%]\" is left ( x ) or top ( y ), \"[50%]\" is middle and \"[100%]\" is right ( x ) or bottom ( y ) alignment. Dynamically defined position: See below . Here is an example of using absolute and relative position coordinates: slide.box(x=0, y=10).text(\"Box 1\") row = slide.box(width=\"fill\") row.box(x=\"20%\").text(\"Box 2\") row.box(x=\"60%\").text(\"Box 3\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Default position # The default positioning of a box depends on the axis of its parent. The following explanation assumes a vertical box. For a horizontal box, the main and cross axes would be swapped. Children of a box will be by default centered along the cross axis. In the case of a vertical parent box, the x attribute would be set to \"[50%]\" , i.e. child boxes will be horizontally centered. For the main axis, the behaviour is more complex. When a box has its main axis position set to None , it is a managed box . A parent box stacks all of its managed children boxes along its main axis one-by-one. In addition, it also centers all of its children together along the main axis. slide.box().text(\"Box 1\") slide.box().text(\"Box 2\") slide.box().text(\"Box 3\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } In the above example, the slide is a parent vertical box. Its three children will thus be laid below one another, they will be centered horizontally, and all of them together will also be centered vertically. Here is the same situation with a horizontal parent box: row = slide.box(horizontal=True) row.box().text(\"Box 1\") row.box().text(\"Box 2\") row.box().text(\"Box 3\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Dynamic positions # Box position can also be defined dynamically with respect to other boxes. You can get a position that is relative to the final position of a box using the x or y methods. The returned value of these methods will be a proxy object that will resolve the actual final position after layout is computed. The reference point of these two methods is the top-left corner of the target box. The parameter can be either: int or float : Resolves to the given number of pixels from the reference point. The value can be negative. \"<number>%\" : Resolves to the ratio of the size of the box added to the reference point. For example: .x(\"0%\") returns the left-most x coordinate of the box. .x(\"50%\") returns the x coordinate of the middle of the box. .x(\"100%\") return the right-most x coordinate of the box. .x(10) returns the left-most x coordinate of the box, moved by 10 pixels to the right. Here you can observe dynamic positions in action: b = slide.box(width=100, height=100, name=\"First\") slide.box(x=b.x(\"50%\"), y=b.y(\"50%\"), width=100, height=100, name=\"Second\") slide.box(x=0, y=b.y(\"100%\"), width=\"100%\", height=200, name=\"Third\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } In addition to using the individual x and y methods, you can also use the p method to create a dynamic point, which will again be resolved after the layout is fully computed. You can also further move this point via the add method. This is mostly useful for defining points of lines and polygons . Modifying render order # By default, boxes are rendered by performing a depth-first walk through the layout tree. Each child is visited in the order in which it was defined. In the following example, the blue box is rendered over all the previous boxes as it was defined the last. slide.box(x=40, y=20, width=80, height=120).rect(bg_color=\"red\") slide.box(x=50, y=30, width=80, height=80).rect(bg_color=\"green\") slide.box(x=60, y=40, width=80, height=80).rect(bg_color=\"blue\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You have several options how to change the rendering order: Use the prepend parameter when creating a box. This will insert it as the first child of the parent box, instead of the last. slide.box(x=40, y=20, width=80, height=120).rect(bg_color=\"red\") slide.box(x=50, y=30, width=80, height=80).rect(bg_color=\"green\") slide.box(x=60, y=40, width=80, height=80, prepend=True).rect(bg_color=\"blue\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Use the below or above parameters when creating a box to place the newly created box above/below the box passed in the parameter. a = slide.box(x=40, y=20, width=80, height=120) a.rect(bg_color=\"red\") slide.box(x=50, y=30, width=80, height=80, below=a).rect(bg_color=\"green\") slide.box(x=60, y=40, width=80, height=80).rect(bg_color=\"blue\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can also move boxes in the z axis using the z_level parameter. Before the final paint, all drawing elements will be sorted using a stable sort by their z_level . An element with a larger z_level will be drawn after an element with a small z_level . If the z_level is not specified, it is inherited from the parent box. The root box has z_level set to 0 . slide.box(x=40, y=20, width=80, height=120, z_level=3).rect(bg_color=\"red\") slide.box(x=50, y=30, width=80, height=80, z_level=2).rect(bg_color=\"green\") slide.box(x=60, y=40, width=80, height=80, z_level=1).rect(bg_color=\"blue\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Layout"},{"location":"userguide/layout/#layout","text":"Elsie contains a layout system which allows you to quickly build scenarios that are common in presentations, while still providing the option of finely tuned customization for situations where every pixel placement matters. The central element of the layout system is the Box . Each Elsie slide contains a layout hierarchy tree. The internal nodes of the tree are boxes and the leaves are box items . Boxes are layout containers, which do not produce any visual content, but they dictate how are their children laid out on a slide. Box items are individual paintable items, such as text, images, shapes, etc. Anything that can be rendered by Elsie thus has an accompanied parent box which decides its size and position on a slide.","title":"Layout"},{"location":"userguide/layout/#creating-boxes","text":"To create a new box, you can call the box method on an existing Box . This will return a new box which will be a child of the box object on which you call the box method. The root box of the slide layout hierarchy is available to you as the return value of the new_slide method or the slide decorator. Here we create three boxes as children of the top-level slide box and create a child text item in each box. slide.box().text(\"Box 1\") slide.box().text(\"Box 2\") slide.box().text(\"Box 3\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Note: for brevity, most code snippets in this user guide assume that there is a slides variable containing a SlideDeck object and a slide variable containing a Slide object. The render method call is also omitted from most of the examples that display rendered slide output. The output from the code snippets is rendered into PNG images instead of SVG images to ensure that they will be displayed consistently on each device.","title":"Creating boxes"},{"location":"userguide/layout/#debug-draw-mode","text":"The boxes themselves are invisible, but they have caused the three text items to be rendered below one another. If you are fine-tuning or debugging the layout of your slide, and you want to see the extents and bounds of your boxes, you can use the debug_boxes parameter when creating a slide: @slides.slide(debug_boxes=True) def three_boxes_debug(slide): slide.box().text(\"Box 1\") slide.box().text(\"Box 2\") slide.box().text(\"Box 3\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can see that there is a single root box that wraps the whole slide and then there are three individual boxes in the middle. The box debug draw mode will be used in some examples on this page to demonstrate the extents of individual boxes.","title":"Debug draw mode"},{"location":"userguide/layout/#default-box-layout-properties","text":"Newly created boxes have the following behavior by default: They occupy as few space as possible. You can change this by modifying their size . Children are placed vertically in a column, in the order in which they were created. You can change this by modifying their axis . Children are centered vertically and horizontally. You can change this by modifying their position . In the following sections below we will see how these default positioning and sizing rules can be changed.","title":"Default box layout properties"},{"location":"userguide/layout/#box-naming","text":"Boxes can be named with the name parameter ( .box(name=\"My box\") ). It has no impact on normal rendering of the slide, but the name will be shown if the box debug draw mode is enabled. If you use the @slides.slide() decorator, the name of the top-level slide will be set to the name of the function on which the decorator was used.","title":"Box naming"},{"location":"userguide/layout/#box-axis","text":"Boxes can either be vertical or horizontal : Vertical boxes place its child items vertically in a column. Their main axis is vertical and their cross axis is horizontal. Horizontal boxes place its child items horizontally in a row. Their main axis is horizontal and their cross axis is vertical. Boxes are vertical by default, if you want to create a horizontal box, use the horizontal=True parameter when creating a box: box = slide.box(horizontal=True) box.box().text(\"Box 1\") box.box().text(\"Box 2\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Box axis"},{"location":"userguide/layout/#composing-boxes","text":"By composing boxes, you can create complex hierarchical row and column layouts. row = slide.box(horizontal=True) col_a = row.box() col_a.box().text(\"Col. A/1\") col_a.box().text(\"Col. A/2\") col_b = row.box() col_b.box().text(\"Col. B/1\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Note that almost all methods on a box will create a new box ( box ) or an item (e.g. text or rect ). Leaf items cannot contain children, but for convenience they also offer most of the methods available on boxes, which they delegate to their parent. Therefore, the following two snippets will create the same slide content: # A: create text on its parent box box = slide.box() box.rect(bg_color=\"#aaf\") box.text(\"Hello!\") # B: create text on its sibling rectangle slide.box().rect(bg_color=\"#aaf\").text(\"Hello!\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Composing boxes"},{"location":"userguide/layout/#sizing-boxes","text":"You can change the width and height of a box by using the width and height parameters of the box method. Here we create three boxes ( A , B and C ). Box A has a default size, which is set according to the required size of its text child. Box B has a width of 300 pixels and height of 100 pixels. Box C has width equal to the full width of its parent and height is again set to the height of its child text item. slide.box(name=\"A\").text(\"Box 1\") slide.box(name=\"B\", width=300, height=100).text(\"Box 2\") slide.box(name=\"C\", width=\"100%\").text(\"Box 3\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } The width and height parameters define the minimal size of the box. Therefore, if its children (child boxes, text items, etc.) request a larger size, the box will use the requested size of its content.","title":"Sizing boxes"},{"location":"userguide/layout/#size-value-formats","text":"You can enter width and height values in several formats: None (the default): No minimal size request. int , float or a string containg only digits: Exact minimal size defined in pixels. \"<number>%\" (e.g. \"50%\" ): Minimal size in percentage of the parent box size. \"fill\" or \"fill(<number>)\" : The box will fill all available space of the parent box. If there are more boxes on the same level which use fill, then the size will be distributed amongst them, while respecting the ratio of the fill parameter. For example, when one box has argument fill(2) and the second one fill(3) , the remaining size will be divided using the ratio 2:3 . Using just \"fill\" is a shortcut for \"fill(1)\" . The following code shows an example of \"fill\" usage: slide.box(width=\"fill\").text(\"Box 1\") box = slide.box(width=300, height=180) box.box(height=\"fill(1)\").text(\"Box 2\") box.box(height=\"fill(2)\").text(\"Box 3\") slide.box(height=\"fill\").text(\"Box 4\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Size value formats"},{"location":"userguide/layout/#aliases-for-commonly-sized-boxes","text":"Elsie contains three shortcuts for creating boxes with common minimal size requirements: fbox (fill-box): shortcut for box(width=\"fill\", height=\"fill\") . sbox (stretch-box): shortcut for box(width=\"fill\") if the parent box has a vertical layout or box(height=\"fill\") if the parent box has a horizontal layout. In other words, it fills the box in the cross axis. overlay : shortcut for box(x=0, y=0, width=\"100%\", height=\"100%) . This can be used if you want to overlay several boxes on top of each other, which is useful especially in combination with revealing .","title":"Aliases for commonly sized boxes"},{"location":"userguide/layout/#padding","text":"By default, each box gives all of its space to its children. This can be modified by padding. There are four padding values: left , right , top , and bottom . They can be modified with the p_left , p_right , p_top , and p_bottom parameters of the box method. After the layout of the parent box is computed and the final size and position of a box is known, the padding will shrink its size in the specified directions. slide.box(width=160, height=100, p_left=40, name=\"Top box\") slide.box(width=160, height=150, p_y=50, name=\"Bottom box\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } In the above example, the top box is shrunk by 40 pixels from the left. Note that the padding is applied after the layout was calculated, therefore the box was first centered horizontally, and then the padding reduced its size. The bottom box is shrunk by 50 pixels from the top and from the bottom. You can also use the following padding shortcut parameters of the box method: p_x sets both p_left and p_right . p_y sets both p_top and p_bottom . padding sets all four paddings at once.","title":"Padding"},{"location":"userguide/layout/#positioning-boxes","text":"You can set the position of the top-left corner of a box via the x and y parameters of the box method. You can enter the x and y positions in several formats: None (default): Set the default position (see below ). int , float or a string containing only digits: Set absolute position in pixels. Coordinates are relative to the top-left corner of the parent box. \"<number>% : Set position relative to the parent box. \"0%\" represents the left ( x ) or top ( y ) edge of the parent and \"100%\" the right ( x ) or bottom ( y ) edge of the parent. \"[<number>%] : Align the box in the parent box. \"[0%]\" is left ( x ) or top ( y ), \"[50%]\" is middle and \"[100%]\" is right ( x ) or bottom ( y ) alignment. Dynamically defined position: See below . Here is an example of using absolute and relative position coordinates: slide.box(x=0, y=10).text(\"Box 1\") row = slide.box(width=\"fill\") row.box(x=\"20%\").text(\"Box 2\") row.box(x=\"60%\").text(\"Box 3\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Positioning boxes"},{"location":"userguide/layout/#default-position","text":"The default positioning of a box depends on the axis of its parent. The following explanation assumes a vertical box. For a horizontal box, the main and cross axes would be swapped. Children of a box will be by default centered along the cross axis. In the case of a vertical parent box, the x attribute would be set to \"[50%]\" , i.e. child boxes will be horizontally centered. For the main axis, the behaviour is more complex. When a box has its main axis position set to None , it is a managed box . A parent box stacks all of its managed children boxes along its main axis one-by-one. In addition, it also centers all of its children together along the main axis. slide.box().text(\"Box 1\") slide.box().text(\"Box 2\") slide.box().text(\"Box 3\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } In the above example, the slide is a parent vertical box. Its three children will thus be laid below one another, they will be centered horizontally, and all of them together will also be centered vertically. Here is the same situation with a horizontal parent box: row = slide.box(horizontal=True) row.box().text(\"Box 1\") row.box().text(\"Box 2\") row.box().text(\"Box 3\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Default position"},{"location":"userguide/layout/#dynamic-positions","text":"Box position can also be defined dynamically with respect to other boxes. You can get a position that is relative to the final position of a box using the x or y methods. The returned value of these methods will be a proxy object that will resolve the actual final position after layout is computed. The reference point of these two methods is the top-left corner of the target box. The parameter can be either: int or float : Resolves to the given number of pixels from the reference point. The value can be negative. \"<number>%\" : Resolves to the ratio of the size of the box added to the reference point. For example: .x(\"0%\") returns the left-most x coordinate of the box. .x(\"50%\") returns the x coordinate of the middle of the box. .x(\"100%\") return the right-most x coordinate of the box. .x(10) returns the left-most x coordinate of the box, moved by 10 pixels to the right. Here you can observe dynamic positions in action: b = slide.box(width=100, height=100, name=\"First\") slide.box(x=b.x(\"50%\"), y=b.y(\"50%\"), width=100, height=100, name=\"Second\") slide.box(x=0, y=b.y(\"100%\"), width=\"100%\", height=200, name=\"Third\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } In addition to using the individual x and y methods, you can also use the p method to create a dynamic point, which will again be resolved after the layout is fully computed. You can also further move this point via the add method. This is mostly useful for defining points of lines and polygons .","title":"Dynamic positions"},{"location":"userguide/layout/#modifying-render-order","text":"By default, boxes are rendered by performing a depth-first walk through the layout tree. Each child is visited in the order in which it was defined. In the following example, the blue box is rendered over all the previous boxes as it was defined the last. slide.box(x=40, y=20, width=80, height=120).rect(bg_color=\"red\") slide.box(x=50, y=30, width=80, height=80).rect(bg_color=\"green\") slide.box(x=60, y=40, width=80, height=80).rect(bg_color=\"blue\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You have several options how to change the rendering order: Use the prepend parameter when creating a box. This will insert it as the first child of the parent box, instead of the last. slide.box(x=40, y=20, width=80, height=120).rect(bg_color=\"red\") slide.box(x=50, y=30, width=80, height=80).rect(bg_color=\"green\") slide.box(x=60, y=40, width=80, height=80, prepend=True).rect(bg_color=\"blue\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Use the below or above parameters when creating a box to place the newly created box above/below the box passed in the parameter. a = slide.box(x=40, y=20, width=80, height=120) a.rect(bg_color=\"red\") slide.box(x=50, y=30, width=80, height=80, below=a).rect(bg_color=\"green\") slide.box(x=60, y=40, width=80, height=80).rect(bg_color=\"blue\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can also move boxes in the z axis using the z_level parameter. Before the final paint, all drawing elements will be sorted using a stable sort by their z_level . An element with a larger z_level will be drawn after an element with a small z_level . If the z_level is not specified, it is inherited from the parent box. The root box has z_level set to 0 . slide.box(x=40, y=20, width=80, height=120, z_level=3).rect(bg_color=\"red\") slide.box(x=50, y=30, width=80, height=80, z_level=2).rect(bg_color=\"green\") slide.box(x=60, y=40, width=80, height=80, z_level=1).rect(bg_color=\"blue\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Modifying render order"},{"location":"userguide/lists/","text":"Lists # Lists of items are very common in presentations, and they come in all sorts of forms and shapes. That makes it quite difficult to find a general abstraction that could be used to create an arbitrary list. At the same time, often you just want a quick way to create a simple list, without bells and whistles. For that reason, Elsie does not provide direct list support in its core, but it provides a set of helper utilities for creating lists. They are located in the elsie.ext module, which contains opinionated extensions on top of the Elsie core. If the helper utilities fit your needs, feel free to use them. If not, you can just implement your own functions for creating lists in your presentations. Creating lists # To create a list, you can use either the unordered_list or the ordered_list function. Simply pass it a parent box which will contain the list and then use the returned object to create new list items with the item method: from elsie.ext import unordered_list lst = unordered_list(slide.box()) lst.item().text(\"Item 1\") lst.item().text(\"Item 2\") lst.item().text(\"Item 3\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can also pass several useful options to these functions: indent : Default horizontal gap between individual indentation levels label_padding : Horizontal padding between the item label and its content label : Either a string or a function that will be used to render the label of each item. start (only for ordered_list ): The sequence number at which will the ordered list start. Any additional keyword arguments passed to these functions will be passed to the box created for each list item. The only difference between ordered and unordered lists is the render function of their label. By default, unordered lists have a constant bullet point used as a label ( \u2022 ). The label of an ordered list is rendered as a sequence of arabic numbers joined with a dot (e.g. 1.3.2 ). You can change the label with the label parameter. Nesting lists # Both unordered_list and ordered_list return an object which holds a list of counter values, one for each nesting level. Each call of the item method will create a new item in the list and increment the value of the last counter in the list. A top level list is not nested, so it only has a single counter. You can call the ul or ol method to create an unordered, respectively ordered nested (indented) sublist. By default, the last counter value if the new sublist will start at 1 , but you can override this with the start parameter for ordered lists. from elsie.ext import ordered_list lst = ordered_list(slide.box()) lst.item().text(\"Item 1\") # Counters of lst = [1] l2 = lst.ol() # Counters of l2 = [1, 1] l2.item().text(\"Nested item 1\") # Counters of l2 = [1, 2] l2.item().text(\"Nested item 2\") l3 = l2.ol(start=4) # Counters of l3 = [1, 2, 4] l3.item().text(\"Nested item 3\") lst.item().text(\"Item 2\") # Counters of lst = [2] .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } If you use a function to render the label of your list items, it will be passed a Box which should be filled with the label content and also a list of counter values for the specific list item. This is especially useful for ordered lists: from elsie.ext import ordered_list def render_label(box, counters): style = elsie.TextStyle() if len(counters) == 1: # Top-level label style.bold = True box.text(\".\".join(str(c) for c in counters), style=style) lst = ordered_list(slide.box(), label=render_label) lst.item().text(\"Item 1\") l2 = lst.ol(label=render_label) l2.item().text(\"Nested item 1\") l2.item().text(\"Nested item 2\") lst.item().text(\"Item 2\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can also pass additional parameters to the ul and ol methods to override the default properties of the sublist (such as its label). Note that the label is not inherited by the sublist from the parent. For convenience, you can also use (sub)lists with the with keyword to create visually indented blocks (this is purely visual, it does not change the behaviour of the list in any way): from elsie.ext import unordered_list lst = unordered_list(slide.box()) lst.item().text(\"Item 1\") with lst.ul(label=\"-\") as l2: l2.item().text(\"Nested item 1\") l2.ul().item().text(\"Nested item 2\") # The label here is not inherited lst.item().text(\"Item 2\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Revealing # Using revealing , you can easily create a list of items that will be revealed gradually. If you do not set the show key in the default box arguments for a list, it will use show=\"last+\" , which is handy for showing indented items at the same time as their parent item: from elsie.ext import unordered_list lst = unordered_list(slide.box()) lst.item().text(\"Appears in fragment 1\") lst.item(show=\"next+\").text(\"Appears in fragment 2\") lst.ul().item().text(\"(nested) Appears in fragment 2\") lst.item(show=\"next+\").text(\"Appears in fragment 3\") < Fragment: 1 > (function () { var active_step = 1; var max_step = 3; var slide_id = \".elsie-wrapper-875e8e1956754b6285f74bee98f62504\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Lists"},{"location":"userguide/lists/#lists","text":"Lists of items are very common in presentations, and they come in all sorts of forms and shapes. That makes it quite difficult to find a general abstraction that could be used to create an arbitrary list. At the same time, often you just want a quick way to create a simple list, without bells and whistles. For that reason, Elsie does not provide direct list support in its core, but it provides a set of helper utilities for creating lists. They are located in the elsie.ext module, which contains opinionated extensions on top of the Elsie core. If the helper utilities fit your needs, feel free to use them. If not, you can just implement your own functions for creating lists in your presentations.","title":"Lists"},{"location":"userguide/lists/#creating-lists","text":"To create a list, you can use either the unordered_list or the ordered_list function. Simply pass it a parent box which will contain the list and then use the returned object to create new list items with the item method: from elsie.ext import unordered_list lst = unordered_list(slide.box()) lst.item().text(\"Item 1\") lst.item().text(\"Item 2\") lst.item().text(\"Item 3\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can also pass several useful options to these functions: indent : Default horizontal gap between individual indentation levels label_padding : Horizontal padding between the item label and its content label : Either a string or a function that will be used to render the label of each item. start (only for ordered_list ): The sequence number at which will the ordered list start. Any additional keyword arguments passed to these functions will be passed to the box created for each list item. The only difference between ordered and unordered lists is the render function of their label. By default, unordered lists have a constant bullet point used as a label ( \u2022 ). The label of an ordered list is rendered as a sequence of arabic numbers joined with a dot (e.g. 1.3.2 ). You can change the label with the label parameter.","title":"Creating lists"},{"location":"userguide/lists/#nesting-lists","text":"Both unordered_list and ordered_list return an object which holds a list of counter values, one for each nesting level. Each call of the item method will create a new item in the list and increment the value of the last counter in the list. A top level list is not nested, so it only has a single counter. You can call the ul or ol method to create an unordered, respectively ordered nested (indented) sublist. By default, the last counter value if the new sublist will start at 1 , but you can override this with the start parameter for ordered lists. from elsie.ext import ordered_list lst = ordered_list(slide.box()) lst.item().text(\"Item 1\") # Counters of lst = [1] l2 = lst.ol() # Counters of l2 = [1, 1] l2.item().text(\"Nested item 1\") # Counters of l2 = [1, 2] l2.item().text(\"Nested item 2\") l3 = l2.ol(start=4) # Counters of l3 = [1, 2, 4] l3.item().text(\"Nested item 3\") lst.item().text(\"Item 2\") # Counters of lst = [2] .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } If you use a function to render the label of your list items, it will be passed a Box which should be filled with the label content and also a list of counter values for the specific list item. This is especially useful for ordered lists: from elsie.ext import ordered_list def render_label(box, counters): style = elsie.TextStyle() if len(counters) == 1: # Top-level label style.bold = True box.text(\".\".join(str(c) for c in counters), style=style) lst = ordered_list(slide.box(), label=render_label) lst.item().text(\"Item 1\") l2 = lst.ol(label=render_label) l2.item().text(\"Nested item 1\") l2.item().text(\"Nested item 2\") lst.item().text(\"Item 2\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can also pass additional parameters to the ul and ol methods to override the default properties of the sublist (such as its label). Note that the label is not inherited by the sublist from the parent. For convenience, you can also use (sub)lists with the with keyword to create visually indented blocks (this is purely visual, it does not change the behaviour of the list in any way): from elsie.ext import unordered_list lst = unordered_list(slide.box()) lst.item().text(\"Item 1\") with lst.ul(label=\"-\") as l2: l2.item().text(\"Nested item 1\") l2.ul().item().text(\"Nested item 2\") # The label here is not inherited lst.item().text(\"Item 2\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Nesting lists"},{"location":"userguide/lists/#revealing","text":"Using revealing , you can easily create a list of items that will be revealed gradually. If you do not set the show key in the default box arguments for a list, it will use show=\"last+\" , which is handy for showing indented items at the same time as their parent item: from elsie.ext import unordered_list lst = unordered_list(slide.box()) lst.item().text(\"Appears in fragment 1\") lst.item(show=\"next+\").text(\"Appears in fragment 2\") lst.ul().item().text(\"(nested) Appears in fragment 2\") lst.item(show=\"next+\").text(\"Appears in fragment 3\") < Fragment: 1 > (function () { var active_step = 1; var max_step = 3; var slide_id = \".elsie-wrapper-875e8e1956754b6285f74bee98f62504\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Revealing"},{"location":"userguide/markdown/","text":"Markdown # Since Elsie is a rather low-level tool, in certain situations it might feel too verbose. For some slides, you may just want to display some text with basic formatting, and you don't want to think about the layout too much. For such scenarios we provide basic integration with Markdown , located in the elsie.ext extension module, which contains opinionated extensions on top of the Elsie core. Markdown support is provided on a best-effort basis, as it intentionally does not support all Markdown use cases in order to stay simple. Rendering Markdown markup # You can pass a snippet of Markdown markup to the markdown function, which will transform it into Elsie elements and render it into the given parent box: from elsie.ext import markdown markdown(slide.box(), \"\"\" # Hello This text was rendered using **Markdown** \"\"\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You have to use the CommonMark Markdown syntax. Supported Markdown subset # Elsie supports only a subset of Markdown elements. Here is a list of supported elements: Formatted text # You can use headings, paragraphs, blockquotes and text formatting (bold/italic). Line breaks in the markup will be respected. from elsie.ext import markdown markdown(slide.box(), \"\"\" # Heading 1 ## Heading 2 **bold text** *italic text* **bold *and italic* text** \"\"\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can use inline styles inside text to format parts of the text differently. The default escape character is ~ , but you can change it with the escape_char parameter of the markdown function. from elsie.ext import markdown markdown(slide.box(), \"\"\" This text is in ~tt{monospace}. \"\"\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can also override the default style used to render headings, bold text etc. Fenced code # Fenced code blocks will be rendered with syntax-highlighting. Pass the desired language to be highlighted after the initial three backticks, for example: from elsie.ext import markdown markdown(slide.box(), \"\"\" This is Python code: ```python def say_hello(): print(\"Hello world\") ``` \"\"\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Lists # You can use both unordered lists and ordered lists and also nest them. Unordered lists support two types of bullet points ( - or * ), ordered lists support the format <number>. : from elsie.ext import markdown markdown(slide.box(), \"\"\" - Item A 1. Item B 1. Item C - Item D * Item E * Item F \"\"\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Links # You can also use Markdown links inside the markup, but this will only affect the formatting of the text. It will not cause the link to be clickable in the resulting PDF, nor will it render an underline. This is a limitation of Inkscape and it might be resolved in the future. from elsie.ext import markdown markdown(slide.box(), \"\"\" I am a [link](unused). \"\"\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Horizontal rules, tables, inline code, images, footnotes and indented code blocks are currently not supported. Overriding styles # The markdown function uses a set of predefined styles for formatting bold/italic text, individual levels of headings etc. If the parent box into which you render Markdown already has some of these styles defined, the default style will be overridden by them. Using this overriding you can change the default appearance of the rendered Markdown elements: from elsie import TextStyle from elsie.ext import markdown from elsie.ext.markdown import MD_PARAGRAPH_STYLE slide.set_style(MD_PARAGRAPH_STYLE, TextStyle(color=\"red\")) markdown(slide.box(), \"This is a red paragraph.\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Here is a list of the Markdown styles that you can override: Style name Used for Variable name in elsie.ext.markdown \"md-paragraph\" Paragraphs MD_PARAGRAPH_STYLE \"md-bold\" Bold text MD_BOLD_STYLE \"md-italic\" Italic text MD_ITALIC_STYLE \"md-link\" Links MD_LINK_STYLE \"md-blockquote\" Blockquotes MD_BLOCKQUOTE_STYLE \"md-heading-<level>\" Headings of the given level ( 1-6 ) MD_HEADING_<level>_STYLE You can either use the names directly or import them from the elsie.ext.markdown module. Fenced code blocks use the standard code style, so you can override that if you want to alter the appearance of code snippets rendered with Markdown.","title":"Markdown"},{"location":"userguide/markdown/#markdown","text":"Since Elsie is a rather low-level tool, in certain situations it might feel too verbose. For some slides, you may just want to display some text with basic formatting, and you don't want to think about the layout too much. For such scenarios we provide basic integration with Markdown , located in the elsie.ext extension module, which contains opinionated extensions on top of the Elsie core. Markdown support is provided on a best-effort basis, as it intentionally does not support all Markdown use cases in order to stay simple.","title":"Markdown"},{"location":"userguide/markdown/#rendering-markdown-markup","text":"You can pass a snippet of Markdown markup to the markdown function, which will transform it into Elsie elements and render it into the given parent box: from elsie.ext import markdown markdown(slide.box(), \"\"\" # Hello This text was rendered using **Markdown** \"\"\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You have to use the CommonMark Markdown syntax.","title":"Rendering Markdown markup"},{"location":"userguide/markdown/#supported-markdown-subset","text":"Elsie supports only a subset of Markdown elements. Here is a list of supported elements:","title":"Supported Markdown subset"},{"location":"userguide/markdown/#formatted-text","text":"You can use headings, paragraphs, blockquotes and text formatting (bold/italic). Line breaks in the markup will be respected. from elsie.ext import markdown markdown(slide.box(), \"\"\" # Heading 1 ## Heading 2 **bold text** *italic text* **bold *and italic* text** \"\"\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can use inline styles inside text to format parts of the text differently. The default escape character is ~ , but you can change it with the escape_char parameter of the markdown function. from elsie.ext import markdown markdown(slide.box(), \"\"\" This text is in ~tt{monospace}. \"\"\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can also override the default style used to render headings, bold text etc.","title":"Formatted text"},{"location":"userguide/markdown/#fenced-code","text":"Fenced code blocks will be rendered with syntax-highlighting. Pass the desired language to be highlighted after the initial three backticks, for example: from elsie.ext import markdown markdown(slide.box(), \"\"\" This is Python code: ```python def say_hello(): print(\"Hello world\") ``` \"\"\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Fenced code"},{"location":"userguide/markdown/#lists","text":"You can use both unordered lists and ordered lists and also nest them. Unordered lists support two types of bullet points ( - or * ), ordered lists support the format <number>. : from elsie.ext import markdown markdown(slide.box(), \"\"\" - Item A 1. Item B 1. Item C - Item D * Item E * Item F \"\"\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Lists"},{"location":"userguide/markdown/#links","text":"You can also use Markdown links inside the markup, but this will only affect the formatting of the text. It will not cause the link to be clickable in the resulting PDF, nor will it render an underline. This is a limitation of Inkscape and it might be resolved in the future. from elsie.ext import markdown markdown(slide.box(), \"\"\" I am a [link](unused). \"\"\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Horizontal rules, tables, inline code, images, footnotes and indented code blocks are currently not supported.","title":"Links"},{"location":"userguide/markdown/#overriding-styles","text":"The markdown function uses a set of predefined styles for formatting bold/italic text, individual levels of headings etc. If the parent box into which you render Markdown already has some of these styles defined, the default style will be overridden by them. Using this overriding you can change the default appearance of the rendered Markdown elements: from elsie import TextStyle from elsie.ext import markdown from elsie.ext.markdown import MD_PARAGRAPH_STYLE slide.set_style(MD_PARAGRAPH_STYLE, TextStyle(color=\"red\")) markdown(slide.box(), \"This is a red paragraph.\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Here is a list of the Markdown styles that you can override: Style name Used for Variable name in elsie.ext.markdown \"md-paragraph\" Paragraphs MD_PARAGRAPH_STYLE \"md-bold\" Bold text MD_BOLD_STYLE \"md-italic\" Italic text MD_ITALIC_STYLE \"md-link\" Links MD_LINK_STYLE \"md-blockquote\" Blockquotes MD_BLOCKQUOTE_STYLE \"md-heading-<level>\" Headings of the given level ( 1-6 ) MD_HEADING_<level>_STYLE You can either use the names directly or import them from the elsie.ext.markdown module. Fenced code blocks use the standard code style, so you can override that if you want to alter the appearance of code snippets rendered with Markdown.","title":"Overriding styles"},{"location":"userguide/revealing/","text":"Revealing # Presentations often contain slides that are revealed gradually in several steps (usually called fragments ). Elsie allows you to create multiple fragments per slide and selectively show individual boxes in specific fragments using the show parameter. Fragments on a slide are counted from 1 and there is always at least a single fragment in each slide. The number of fragments of a slide is determined by the highest fragment number in which some box is visible. To display a box in a specific fragment, pass the fragment number as a string to the show parameter: slide.box().text(\"Box 1\") slide.box(show=\"2\").text(\"Box 2\") < Fragment: 1 > (function () { var active_step = 1; var max_step = 2; var slide_id = \".elsie-wrapper-666466d0ba8c43a29c58d6cf6019ea93\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } The slide above has two fragments, because the second box will be shown in fragment 2 . You can use the buttons below the slide to move between individual fragments. Fragment visibility is hierarchical, i.e. if you hide a parent, all of its children will be hidden as well: box = slide.box(show=\"2\") box.box().text(\"Box 1\") box.box().text(\"Box 2\") < Fragment: 1 > (function () { var active_step = 1; var max_step = 2; var slide_id = \".elsie-wrapper-757b19d3322d494ab289450ba7e1afa3\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Fragment selectors # In addition to choosing a single specific fragment in which should a box be displayed, there are other values that you can pass to the show parameter: None (default): The box will be shown in all steps. This is equivalent to passing \"1+\" . \"<number>\" : The box will be shown only in the fragment with the given number. \"<number>+\" : The box will be shown in the fragment with the given number and also in all following fragments. This is called an open fragment range. \"<from>-<to>\" : The box will be shown in fragment from and it will stay shown until fragment to . This is called a closed fragment range. The range is inclusive from both sides. Here is an example of the various show values in action: slide.box().text(\"Box 1\") slide.box(show=\"2-3\").text(\"Box 2\") slide.box(show=\"2+\").text(\"Box 3\") slide.box(show=\"4\").text(\"Box 4\") < Fragment: 1 > (function () { var active_step = 1; var max_step = 4; var slide_id = \".elsie-wrapper-6bf334f822364b8fba5d23f8b65fbf2e\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } The first box will be shown in all fragments, the second box in fragments 2 and 3 , the third box in all fragments from 2 to the end, and the fourth box will be shown only in fragment 4 . The largest fragment number present in the slide is 4 , so the slide will have four fragments in total. Fragment placeholders # If you have a lot of fragments on a slide, it might be tedious to count the fragment numbers manually and keep them in sync when you make changes to the slide. To make this process easier, you can use placeholders to refer to the current fragment. The current fragment is the fragment with the largest number defined on a slide so far. You can access its number using the current_fragment method. This value changes dynamically as you add more fragments to the slide: # slide.current_fragment() == 1 slide.box().text(\"Box 1\") # slide.current_fragment() == 1 slide.box(show=\"2\").text(\"Box 1\") # slide.current_fragment() == 2 slide.box(show=\"3\").text(\"Box 1\") # slide.current_fragment() == 3 To leverage the current fragment, you can use two placeholders in place of a fragment number passed to show : The \"last\" placeholder resolves to the value of the current fragment. The \"next\" placeholder increments the current fragment and then resolves to the incremented value. Using the placeholders, you can show boxes in the same order as they appear in the source code. Here is an example of their usage: slide.box().text(\"Box 1\") # Moves current fragment to 2 and shows the box in fragment 2 slide.box(show=\"next\").text(\"Box 2\") # Shows the box in fragment 2 slide.box(show=\"last\").text(\"Box 3\") # Moves current fragment to 3 and shows the box in fragment 3 slide.box(show=\"next\").text(\"Box 4\") < Fragment: 1 > (function () { var active_step = 1; var max_step = 3; var slide_id = \".elsie-wrapper-b4c140c5f19b47aba9bb53e708c3c53d\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can also combine the placeholders with open fragment ranges: slide.box().text(\"List item 1\") slide.box(show=\"next+\").text(\"List item 2\") slide.box(show=\"last+\", p_left=20).text(\"Subitem 1\") slide.box(show=\"last+\", p_left=20).text(\"Subitem 2\") slide.box(show=\"next+\").text(\"List item 3\") slide.box(show=\"last+\", p_left=20).text(\"Subitem 1\") < Fragment: 1 > (function () { var active_step = 1; var max_step = 3; var slide_id = \".elsie-wrapper-6a94be38c5be4747a13db3d21c559def\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Overlaying boxes # As you may have already noticed, using show only influences the visibility of a box, not its layout. Therefore, the space for a box is allocated in each fragment, even if the box is not visible in that fragment (if you know CSS, fragment visibility behaves like visibility: hidden , not display: none ). If you instead want to show boxes gradually on top of one another, you can use the overlay shortcut to render a box at the same location and size as another box. slide.overlay(show=\"1\").text(\"Box 1\") slide.overlay(show=\"2\").text(\"Box 2\") slide.overlay(show=\"3\").text(\"Box 3\") < Fragment: 1 > (function () { var active_step = 1; var max_step = 3; var slide_id = \".elsie-wrapper-f0d9a3d7ac47470dbc13f0af252d5ba4\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } When using overlays, make sure that the box that you are overlaying is actually visible in the fragment when you want it to be overlaid. For example, this may not work as expected: box = slide.box(show=\"1\").text(\"Box 1\") box.overlay(show=\"2\").text(\"Box 2\") box.overlay(show=\"3\").text(\"Box 3\") < Fragment: 1 > (function () { var active_step = 1; var max_step = 3; var slide_id = \".elsie-wrapper-b4da0024d7e44589949a273283aa70f2\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Because boxes 2 and 3 are children of box 1 , which is only shown in fragment 1 .","title":"Revealing"},{"location":"userguide/revealing/#revealing","text":"Presentations often contain slides that are revealed gradually in several steps (usually called fragments ). Elsie allows you to create multiple fragments per slide and selectively show individual boxes in specific fragments using the show parameter. Fragments on a slide are counted from 1 and there is always at least a single fragment in each slide. The number of fragments of a slide is determined by the highest fragment number in which some box is visible. To display a box in a specific fragment, pass the fragment number as a string to the show parameter: slide.box().text(\"Box 1\") slide.box(show=\"2\").text(\"Box 2\") < Fragment: 1 > (function () { var active_step = 1; var max_step = 2; var slide_id = \".elsie-wrapper-666466d0ba8c43a29c58d6cf6019ea93\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } The slide above has two fragments, because the second box will be shown in fragment 2 . You can use the buttons below the slide to move between individual fragments. Fragment visibility is hierarchical, i.e. if you hide a parent, all of its children will be hidden as well: box = slide.box(show=\"2\") box.box().text(\"Box 1\") box.box().text(\"Box 2\") < Fragment: 1 > (function () { var active_step = 1; var max_step = 2; var slide_id = \".elsie-wrapper-757b19d3322d494ab289450ba7e1afa3\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Revealing"},{"location":"userguide/revealing/#fragment-selectors","text":"In addition to choosing a single specific fragment in which should a box be displayed, there are other values that you can pass to the show parameter: None (default): The box will be shown in all steps. This is equivalent to passing \"1+\" . \"<number>\" : The box will be shown only in the fragment with the given number. \"<number>+\" : The box will be shown in the fragment with the given number and also in all following fragments. This is called an open fragment range. \"<from>-<to>\" : The box will be shown in fragment from and it will stay shown until fragment to . This is called a closed fragment range. The range is inclusive from both sides. Here is an example of the various show values in action: slide.box().text(\"Box 1\") slide.box(show=\"2-3\").text(\"Box 2\") slide.box(show=\"2+\").text(\"Box 3\") slide.box(show=\"4\").text(\"Box 4\") < Fragment: 1 > (function () { var active_step = 1; var max_step = 4; var slide_id = \".elsie-wrapper-6bf334f822364b8fba5d23f8b65fbf2e\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } The first box will be shown in all fragments, the second box in fragments 2 and 3 , the third box in all fragments from 2 to the end, and the fourth box will be shown only in fragment 4 . The largest fragment number present in the slide is 4 , so the slide will have four fragments in total.","title":"Fragment selectors"},{"location":"userguide/revealing/#fragment-placeholders","text":"If you have a lot of fragments on a slide, it might be tedious to count the fragment numbers manually and keep them in sync when you make changes to the slide. To make this process easier, you can use placeholders to refer to the current fragment. The current fragment is the fragment with the largest number defined on a slide so far. You can access its number using the current_fragment method. This value changes dynamically as you add more fragments to the slide: # slide.current_fragment() == 1 slide.box().text(\"Box 1\") # slide.current_fragment() == 1 slide.box(show=\"2\").text(\"Box 1\") # slide.current_fragment() == 2 slide.box(show=\"3\").text(\"Box 1\") # slide.current_fragment() == 3 To leverage the current fragment, you can use two placeholders in place of a fragment number passed to show : The \"last\" placeholder resolves to the value of the current fragment. The \"next\" placeholder increments the current fragment and then resolves to the incremented value. Using the placeholders, you can show boxes in the same order as they appear in the source code. Here is an example of their usage: slide.box().text(\"Box 1\") # Moves current fragment to 2 and shows the box in fragment 2 slide.box(show=\"next\").text(\"Box 2\") # Shows the box in fragment 2 slide.box(show=\"last\").text(\"Box 3\") # Moves current fragment to 3 and shows the box in fragment 3 slide.box(show=\"next\").text(\"Box 4\") < Fragment: 1 > (function () { var active_step = 1; var max_step = 3; var slide_id = \".elsie-wrapper-b4c140c5f19b47aba9bb53e708c3c53d\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can also combine the placeholders with open fragment ranges: slide.box().text(\"List item 1\") slide.box(show=\"next+\").text(\"List item 2\") slide.box(show=\"last+\", p_left=20).text(\"Subitem 1\") slide.box(show=\"last+\", p_left=20).text(\"Subitem 2\") slide.box(show=\"next+\").text(\"List item 3\") slide.box(show=\"last+\", p_left=20).text(\"Subitem 1\") < Fragment: 1 > (function () { var active_step = 1; var max_step = 3; var slide_id = \".elsie-wrapper-6a94be38c5be4747a13db3d21c559def\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Fragment placeholders"},{"location":"userguide/revealing/#overlaying-boxes","text":"As you may have already noticed, using show only influences the visibility of a box, not its layout. Therefore, the space for a box is allocated in each fragment, even if the box is not visible in that fragment (if you know CSS, fragment visibility behaves like visibility: hidden , not display: none ). If you instead want to show boxes gradually on top of one another, you can use the overlay shortcut to render a box at the same location and size as another box. slide.overlay(show=\"1\").text(\"Box 1\") slide.overlay(show=\"2\").text(\"Box 2\") slide.overlay(show=\"3\").text(\"Box 3\") < Fragment: 1 > (function () { var active_step = 1; var max_step = 3; var slide_id = \".elsie-wrapper-f0d9a3d7ac47470dbc13f0af252d5ba4\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } When using overlays, make sure that the box that you are overlaying is actually visible in the fragment when you want it to be overlaid. For example, this may not work as expected: box = slide.box(show=\"1\").text(\"Box 1\") box.overlay(show=\"2\").text(\"Box 2\") box.overlay(show=\"3\").text(\"Box 3\") < Fragment: 1 > (function () { var active_step = 1; var max_step = 3; var slide_id = \".elsie-wrapper-b4da0024d7e44589949a273283aa70f2\"; function getSelector(selector) { return slide_id + \" \" + selector; } function updateState(step) { var step_str = step.toString(); document.querySelector(getSelector(\".elsie-next\")).disabled = step >= max_step; document.querySelector(getSelector(\".elsie-previous\")).disabled = step <= 1; document.querySelector(getSelector(\".elsie-current-step\")).innerText = \"Fragment: \" + step_str; var items = document.querySelectorAll(getSelector(\".elsie-step\")); for (var i = 0; i < items.length; i++) { items[i].style.display = \"none\"; } document.querySelector(getSelector(\".elsie-step.step-\" + step_str)).style.display = \"block\"; } function moveStep(offset) { var new_step = active_step + offset; if (new_step >= 1 && new_step <= max_step) { active_step = new_step; } updateState(active_step); } document.querySelector(getSelector(\".elsie-next\")).addEventListener('click', function() { moveStep(1); }); document.querySelector(getSelector(\".elsie-previous\")).addEventListener('click', function() { moveStep(-1); }); updateState(active_step); })() .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Because boxes 2 and 3 are children of box 1 , which is only shown in fragment 1 .","title":"Overlaying boxes"},{"location":"userguide/shapes/","text":"Shapes # Elsie allows you to draw various SVG shapes into slides: rectangles, (poly)lines, polygons or generic paths. On top of that, it offers an abstraction for arrow heads that can be placed on the ends of lines or paths. Rectangles # You can draw rectangles using the rect method on a box. The position and size of the rectangle will be copied from the box. You can pass the following additional parameters: color=<str or None> : Color used to draw the edges of the rectangle. If you pass None (the default), the edges will not be drawn. stroke_width=<number> : Thickness of the drawn rectangle. stroke_dasharray=<str or None> : Pattern of dashes and gaps to used when drawing the edges of the rectangle. You can find more about this attribute here . bg_color=<str or None> : Color used to fill the rectangle. rx , ry : Radius of rounded corners of the rectangle. rotation=<number> : Rotate the rectangle by the given number of degrees clockwise around its center. An example of drawing a rectangle: box = slide.box(x=\"[50%]\", y=\"[50%]\", width=\"80%\", height=200) box.rect( bg_color=\"green\", color=\"red\", stroke_width=10, stroke_dasharray=\"10 4\", rx=20, ry=20 ) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Ellipses # You can draw ellipses using the ellipse method on a box. The position and size of the ellipse will be copied from the box. If you want to draw a circle , use a square parent box. You can also pass the following additional parameters: color=<str or None> : Color used to draw the edges of the ellipse. If you pass None (the default), the edges will not be drawn. stroke_width=<number> : Thickness of the ellipse. stroke_dasharray=<str or None> : Pattern of dashes and gaps to used when drawing the edges of the ellipse. You can find more about this attribute here . bg_color=<str or None> : Color used to fill the ellipse. rotation=<number> : Rotate the ellipse by the given number of degrees clockwise around its center. An example of drawing an ellipse: box = slide.box(x=\"[50%]\", y=\"[50%]\", width=\"80%\", height=200) box.ellipse( bg_color=\"green\", color=\"red\", stroke_width=10, stroke_dasharray=\"10 4\" ) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Lines and polygons # You can draw lines using the line method and polygons using the polygon . Both of these methods take a list of poinst as their first argument. Each point can be defined as one of the following variants: A tuple (x_value, y_value) : Both values will be interpreted as locations relative to the top-left corner of the parent box of the line/polygon. See box positioning . A dynamic point obtained by calling .p(x_value, y_value) on some box. See dynamic positions . slide.box(width=100, height=100).line([(0, 0), (50, 50)], color=\"red\", stroke_width=5) box = slide.box().text(\"Hello\") slide.box().polygon([ box.p(-20, \"50%\"), box.p(\"50%\", -20), box.p(\"100%\", \"50%\").add(20, 0), box.p(\"50%\", \"100%\").add(0, 20) ], color=\"green\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can pass style attributes to lines and polygons, similarly to rectangles. Arrow heads # An arrow head is defined using the Arrow class. It takes the following attributes: size : Size of the arrow head. angle : Main angle of arrow head. stroke_width : Thickness of the line used to draw the arrow head. If None , the arrow head will be filled. inner : Determines the shape of the arrow head. Value 1 (default) produces a normal arrow, values larger than 1 will produce a diamond shape, values smaller than 1 will produce a sharper arrow. See the effect in the picture below. The effect of the inner value is proportional to the size of the arrow. Arrow attributes reference image: You can attach an arrow head to a line using the start_arrow and end_arrow parameters of the line method. Here is an example of using arrow heads: slide.box(width=100, height=100).line( [(0, 0), (50, 50)], color=\"red\", stroke_width=5, start_arrow=elsie.Arrow(size=20, inner=2.0, angle=30), end_arrow=elsie.Arrow(size=40), ) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Note: the arrow head defines only its shape, not color. The color is always taken from the line to which the arrow head is attached. Paths # You can also draw arbitrary SVG paths using the path method.","title":"Shapes"},{"location":"userguide/shapes/#shapes","text":"Elsie allows you to draw various SVG shapes into slides: rectangles, (poly)lines, polygons or generic paths. On top of that, it offers an abstraction for arrow heads that can be placed on the ends of lines or paths.","title":"Shapes"},{"location":"userguide/shapes/#rectangles","text":"You can draw rectangles using the rect method on a box. The position and size of the rectangle will be copied from the box. You can pass the following additional parameters: color=<str or None> : Color used to draw the edges of the rectangle. If you pass None (the default), the edges will not be drawn. stroke_width=<number> : Thickness of the drawn rectangle. stroke_dasharray=<str or None> : Pattern of dashes and gaps to used when drawing the edges of the rectangle. You can find more about this attribute here . bg_color=<str or None> : Color used to fill the rectangle. rx , ry : Radius of rounded corners of the rectangle. rotation=<number> : Rotate the rectangle by the given number of degrees clockwise around its center. An example of drawing a rectangle: box = slide.box(x=\"[50%]\", y=\"[50%]\", width=\"80%\", height=200) box.rect( bg_color=\"green\", color=\"red\", stroke_width=10, stroke_dasharray=\"10 4\", rx=20, ry=20 ) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Rectangles"},{"location":"userguide/shapes/#ellipses","text":"You can draw ellipses using the ellipse method on a box. The position and size of the ellipse will be copied from the box. If you want to draw a circle , use a square parent box. You can also pass the following additional parameters: color=<str or None> : Color used to draw the edges of the ellipse. If you pass None (the default), the edges will not be drawn. stroke_width=<number> : Thickness of the ellipse. stroke_dasharray=<str or None> : Pattern of dashes and gaps to used when drawing the edges of the ellipse. You can find more about this attribute here . bg_color=<str or None> : Color used to fill the ellipse. rotation=<number> : Rotate the ellipse by the given number of degrees clockwise around its center. An example of drawing an ellipse: box = slide.box(x=\"[50%]\", y=\"[50%]\", width=\"80%\", height=200) box.ellipse( bg_color=\"green\", color=\"red\", stroke_width=10, stroke_dasharray=\"10 4\" ) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Ellipses"},{"location":"userguide/shapes/#lines-and-polygons","text":"You can draw lines using the line method and polygons using the polygon . Both of these methods take a list of poinst as their first argument. Each point can be defined as one of the following variants: A tuple (x_value, y_value) : Both values will be interpreted as locations relative to the top-left corner of the parent box of the line/polygon. See box positioning . A dynamic point obtained by calling .p(x_value, y_value) on some box. See dynamic positions . slide.box(width=100, height=100).line([(0, 0), (50, 50)], color=\"red\", stroke_width=5) box = slide.box().text(\"Hello\") slide.box().polygon([ box.p(-20, \"50%\"), box.p(\"50%\", -20), box.p(\"100%\", \"50%\").add(20, 0), box.p(\"50%\", \"100%\").add(0, 20) ], color=\"green\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can pass style attributes to lines and polygons, similarly to rectangles.","title":"Lines and polygons"},{"location":"userguide/shapes/#arrow-heads","text":"An arrow head is defined using the Arrow class. It takes the following attributes: size : Size of the arrow head. angle : Main angle of arrow head. stroke_width : Thickness of the line used to draw the arrow head. If None , the arrow head will be filled. inner : Determines the shape of the arrow head. Value 1 (default) produces a normal arrow, values larger than 1 will produce a diamond shape, values smaller than 1 will produce a sharper arrow. See the effect in the picture below. The effect of the inner value is proportional to the size of the arrow. Arrow attributes reference image: You can attach an arrow head to a line using the start_arrow and end_arrow parameters of the line method. Here is an example of using arrow heads: slide.box(width=100, height=100).line( [(0, 0), (50, 50)], color=\"red\", stroke_width=5, start_arrow=elsie.Arrow(size=20, inner=2.0, angle=30), end_arrow=elsie.Arrow(size=40), ) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Note: the arrow head defines only its shape, not color. The color is always taken from the line to which the arrow head is attached.","title":"Arrow heads"},{"location":"userguide/shapes/#paths","text":"You can also draw arbitrary SVG paths using the path method.","title":"Paths"},{"location":"userguide/syntax_highlighting/","text":"Syntax highlighting # Elsie uses Pygments to provide syntax highlighting. You can use any supported language from this list . You can use the code function on a box to render text with syntax highlighting. The first parameter of the function is the language syntax that should be highlighted. slide.box().code(\"python\", \"\"\" name = \"Elsie\" print(\"Hello\", name) \"\"\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Differences to text # The code method behaves similarly as the text method, with two exceptions: The code method uses the text style \"code\" as a base style (instead of \"default\" ). If you want to use inline styles, you have to explicitly enable them by passing use_styles=True . Line numbering # You can render line numbers using the parameter line_numbers . The style of line numbers can be modified by changing the code_lineno style. style = slide.get_style( \"code_lineno\", full_style=False ).compose(elsie.TextStyle(color=\"red\")) slide.set_style(\"code_lineno\", style) slide.box().code(\"python\", \"\"\" a = 1 b = 2 c = 3 \"\"\", line_numbers=True) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Line and inline boxes # The text and code methods return a special TextBoxItem item that offers the following two methods: line_box creates a box around a specified line (line numbers are counted from 0). Other arguments are forwarded to the box. You can use this to create e.g. colored boxes around selected code lines. box = slide.box().code(\"python\", \"\"\" name = \"Elsie\" print(\"Hello\", name) \"\"\") box.line_box(1, z_level=-1).rect(bg_color=\"orange\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } inline_box creates a box around text which is wrapped with the given style. If there are multiple occurrences of the specified inline style, you can specify which one do you want by the nth argument. style_name can be any existing style name or a dummy style that starts with the \"#\" character. Dummy styles do not have to be defined and they do not have any visual effect. They serve purely for defining inline boxes. text_item = slide.box().text(\"\"\"This is a long text ~#A{that} takes 3 lines. \"\"\") text_item.inline_box(\"#A\", z_level=-1).rect(bg_color=\"green\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Note that boxes created by line_box and inline_box are always created after the box containing the text. Therefore, to render them below the text, you have to use the z_level or below parameters (see Modifying render order ).","title":"Syntax highlighting"},{"location":"userguide/syntax_highlighting/#syntax-highlighting","text":"Elsie uses Pygments to provide syntax highlighting. You can use any supported language from this list . You can use the code function on a box to render text with syntax highlighting. The first parameter of the function is the language syntax that should be highlighted. slide.box().code(\"python\", \"\"\" name = \"Elsie\" print(\"Hello\", name) \"\"\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Syntax highlighting"},{"location":"userguide/syntax_highlighting/#differences-to-text","text":"The code method behaves similarly as the text method, with two exceptions: The code method uses the text style \"code\" as a base style (instead of \"default\" ). If you want to use inline styles, you have to explicitly enable them by passing use_styles=True .","title":"Differences to text"},{"location":"userguide/syntax_highlighting/#line-numbering","text":"You can render line numbers using the parameter line_numbers . The style of line numbers can be modified by changing the code_lineno style. style = slide.get_style( \"code_lineno\", full_style=False ).compose(elsie.TextStyle(color=\"red\")) slide.set_style(\"code_lineno\", style) slide.box().code(\"python\", \"\"\" a = 1 b = 2 c = 3 \"\"\", line_numbers=True) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Line numbering"},{"location":"userguide/syntax_highlighting/#line-and-inline-boxes","text":"The text and code methods return a special TextBoxItem item that offers the following two methods: line_box creates a box around a specified line (line numbers are counted from 0). Other arguments are forwarded to the box. You can use this to create e.g. colored boxes around selected code lines. box = slide.box().code(\"python\", \"\"\" name = \"Elsie\" print(\"Hello\", name) \"\"\") box.line_box(1, z_level=-1).rect(bg_color=\"orange\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } inline_box creates a box around text which is wrapped with the given style. If there are multiple occurrences of the specified inline style, you can specify which one do you want by the nth argument. style_name can be any existing style name or a dummy style that starts with the \"#\" character. Dummy styles do not have to be defined and they do not have any visual effect. They serve purely for defining inline boxes. text_item = slide.box().text(\"\"\"This is a long text ~#A{that} takes 3 lines. \"\"\") text_item.inline_box(\"#A\", z_level=-1).rect(bg_color=\"green\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Note that boxes created by line_box and inline_box are always created after the box containing the text. Therefore, to render them below the text, you have to use the z_level or below parameters (see Modifying render order ).","title":"Line and inline boxes"},{"location":"userguide/text/","text":"Text # You can render text by calling the text method on a box. By default, it will create a box item that will draw the specified text in the middle of the box: slide.box().text(\"Hello world!\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Text style # Elsie draws text using SVG, so you can use common SVG attributes (such as size, color, font) to modify the appearance of the rendered text. The style of a text is defined by a TextStyle object. Its constructor takes the following parameters: font : Name of the used font. size : Size of the used font. align : Alignment of the text. Allowed values are \"left\" \"middle\" \"right\" Make sure that the box is wide enough for the alignment to take effect. By default, the text box will only be as wide as the contained text, and text alignment might not have the desired effect in such case. line_spacing : Spacing between lines. The value is relative to the size value. color : Color of the text. bold : Make the text bold. itelic : Make the text italic. variant_numeric : Specifies the style of rendering numbers. Allowed values are \"normal\" \"ordinal\" \"slashed-zero\" \"lining-nums\" \"oldstyle-nums\" \"proportinal-nums\" \"tabular-nums\" \"diagonal-fractions\" \"stacked-fractions\" See SVG documentation for their meaning. Each parameter may also be None (the default value). This means that the value will be inherited from its parent style (see below). If you want to use font or text properties that are not available in TextStyle , please let us know . You can pass a text style as a second argument to the text method: slide.text(\"Hello world!\", elsie.TextStyle(size=70, color=\"red\")) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Tip : to avoid repeating the TextStyle class name, you can import it via some short alias: from elsie import TextStyle as s ... slide.box().text(\"Hello world!\", s(color=\"red\")) It might be useful to store a style shared by multiple text blocks into a variable, so that you can quickly change the style of multiple text blocks at once if you want to experiment with various styles. from elsie import TextStyle as s footnote = s(size=16) slide.box().text(\"1: Footnote 1\", style=footnote) ... slide.box().text(\"2: Footnote 2\", style=footnote) Naming text styles # The root SlideDeck object and also all boxes have a dictionary which maps string names to text styles. If you use a string instead of a TextStyle instance, Elsie will try to find a style with the given name in the corresponding box. You can use the set_style method on a box to assign a style to a specific name: slide.set_style(\"text\", elsie.TextStyle(bold=True)) slide.box().text(\"Text 1\", style=\"text\") slide.box().text(\"Text 2\", style=\"text\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Text style inheritance # When a new box is created, it inherits a copy of its parent's style dictionary, which can be used to scope the named styles. Therefore, if you create a named style in the root SlideDeck , it will be available globally to all new boxes created after you create the named style. If you create a named style inside a specific box, it will only be available to the box and its descendants. The two following examples produce the same slide as the Hello world example above: # Setting a style globally for all slides slides.set_style(\"big_red\", elsie.TextStyle(size=70, color=\"red\")) slide = slides.new_slide(name=\"slide1\") slide.text(\"Hello world!\", \"big_red\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } box = slide.box() # Setting style locally for a box box.set_style(\"big_red\", elsie.TextStyle(size=70, color=\"red\")) box.text(\"Hello world!\", \"big_red\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Predefined text styles # There are several predefined global named styles available by default in the root SlideDeck object. You can use them by their name: \"default\" TextStyle(font=\"sans-serif\", color=\"black\", size=28, line_spacing=1.20, align=\"middle\", variant_numeric=\"lining-nums\") \"tt\" TextStyle(font=\"monospace\") \"emph\" TextStyle(italic=True) \"alert\" TextStyle(bold=True, color=\"red\") \"code\" TextStyle(font=\"monospace\", align=\"left\", color=\"#222\" line_spacing=1.20, size=20) \"code_lineno\" TextStyle(color=\"gray\") The default style serves as a base text style for all text operations. Text styles can have some properties unspecified. If a text style is used, and it has some property which is unspecified, the property will be inherited from the default text style. Therefore, you can modify the default style to change the default style of all text items in your presentation. For example, the default color of text can be changed globally like this: default_style = slides.get_style(\"default\") default_style.color = \"orange\" slides.set_style(\"default\", default_style) slide = slides.new_slide(\"slide\") slide.text(\"Hello world!\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Updating named text styles # Since it is a common pattern to get an existing text style by name and update it, Elsie provides a shortcut method for this scenario: update_style : slides.update_style(\"default\", elsie.TextStyle(color=\"orange\")) # is the same as default_style = slides.get_style(\"default\") default_style.color = \"orange\" slides.set_style(\"default\", default_style) If you work with individual TextStyle instances, you can compose them together using the compose method: style_a = elsie.TextStyle(color=\"red\") style_b = style_a.compose(elsie.TestStyle(size=20)) # style_b has color=\"red\" and size=20 Inline text styles # Named styles are especially useful for changing individual sections of text inside a single string passed to the text method. To do this, wrap a section of text that you want to be styled differently with ~<style>{<text>} where style is a name of a style and text is some section of text. slide.set_style(\"red\", elsie.TextStyle(color=\"red\")) slide.text(\"Normal text ~red{red text} ~tt{Typewriter text}\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Inline styles can also be nested arbitrarily. In this case the nested styles will be composed together: slide.set_style(\"red\", elsie.TextStyle(color=\"red\")) slide.text(\"~red{text1 ~tt{text2}}\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can escape the inline style character (by default ~ ) by repeating it (e.g. \"~~\" ). If you need to use the ~ character a lot in your text, you can change it to a different character using the escape_character parameter of the text method. Text scaling # By default, the size of text is determined by the size defined in its text style. This can be changed by the parameter scale_to_fit , which will scale the text to fit the size of its parent box. slide.box(width=200, height=80).text(\"Hello world!\", scale_to_fit=True) slide.box(width=80, height=200).text(\"Hello world!\", scale_to_fit=True) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Text rotation # You can use the rotation parameter to rotate the text by the given angle (in degrees) clockwise around its center. slide.box().text(\"Hello world!\", rotation=45) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Colors # You can define the color of text, shapes and other things using a string that is compatible with SVG. You can use one of the following variants of color definitions: Color name: e.g. green , blue . See list of recognized SVG color names. Hex color value: e.g. #fff , #a0a0a0 . RGB values: e.g. rgb(34, 12, 64, 0.6) . HSL values: e.g. hsl(30, 100%, 50%, 0.6) .","title":"Text"},{"location":"userguide/text/#text","text":"You can render text by calling the text method on a box. By default, it will create a box item that will draw the specified text in the middle of the box: slide.box().text(\"Hello world!\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Text"},{"location":"userguide/text/#text-style","text":"Elsie draws text using SVG, so you can use common SVG attributes (such as size, color, font) to modify the appearance of the rendered text. The style of a text is defined by a TextStyle object. Its constructor takes the following parameters: font : Name of the used font. size : Size of the used font. align : Alignment of the text. Allowed values are \"left\" \"middle\" \"right\" Make sure that the box is wide enough for the alignment to take effect. By default, the text box will only be as wide as the contained text, and text alignment might not have the desired effect in such case. line_spacing : Spacing between lines. The value is relative to the size value. color : Color of the text. bold : Make the text bold. itelic : Make the text italic. variant_numeric : Specifies the style of rendering numbers. Allowed values are \"normal\" \"ordinal\" \"slashed-zero\" \"lining-nums\" \"oldstyle-nums\" \"proportinal-nums\" \"tabular-nums\" \"diagonal-fractions\" \"stacked-fractions\" See SVG documentation for their meaning. Each parameter may also be None (the default value). This means that the value will be inherited from its parent style (see below). If you want to use font or text properties that are not available in TextStyle , please let us know . You can pass a text style as a second argument to the text method: slide.text(\"Hello world!\", elsie.TextStyle(size=70, color=\"red\")) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Tip : to avoid repeating the TextStyle class name, you can import it via some short alias: from elsie import TextStyle as s ... slide.box().text(\"Hello world!\", s(color=\"red\")) It might be useful to store a style shared by multiple text blocks into a variable, so that you can quickly change the style of multiple text blocks at once if you want to experiment with various styles. from elsie import TextStyle as s footnote = s(size=16) slide.box().text(\"1: Footnote 1\", style=footnote) ... slide.box().text(\"2: Footnote 2\", style=footnote)","title":"Text style"},{"location":"userguide/text/#naming-text-styles","text":"The root SlideDeck object and also all boxes have a dictionary which maps string names to text styles. If you use a string instead of a TextStyle instance, Elsie will try to find a style with the given name in the corresponding box. You can use the set_style method on a box to assign a style to a specific name: slide.set_style(\"text\", elsie.TextStyle(bold=True)) slide.box().text(\"Text 1\", style=\"text\") slide.box().text(\"Text 2\", style=\"text\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Naming text styles"},{"location":"userguide/text/#text-style-inheritance","text":"When a new box is created, it inherits a copy of its parent's style dictionary, which can be used to scope the named styles. Therefore, if you create a named style in the root SlideDeck , it will be available globally to all new boxes created after you create the named style. If you create a named style inside a specific box, it will only be available to the box and its descendants. The two following examples produce the same slide as the Hello world example above: # Setting a style globally for all slides slides.set_style(\"big_red\", elsie.TextStyle(size=70, color=\"red\")) slide = slides.new_slide(name=\"slide1\") slide.text(\"Hello world!\", \"big_red\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } box = slide.box() # Setting style locally for a box box.set_style(\"big_red\", elsie.TextStyle(size=70, color=\"red\")) box.text(\"Hello world!\", \"big_red\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Text style inheritance"},{"location":"userguide/text/#predefined-text-styles","text":"There are several predefined global named styles available by default in the root SlideDeck object. You can use them by their name: \"default\" TextStyle(font=\"sans-serif\", color=\"black\", size=28, line_spacing=1.20, align=\"middle\", variant_numeric=\"lining-nums\") \"tt\" TextStyle(font=\"monospace\") \"emph\" TextStyle(italic=True) \"alert\" TextStyle(bold=True, color=\"red\") \"code\" TextStyle(font=\"monospace\", align=\"left\", color=\"#222\" line_spacing=1.20, size=20) \"code_lineno\" TextStyle(color=\"gray\") The default style serves as a base text style for all text operations. Text styles can have some properties unspecified. If a text style is used, and it has some property which is unspecified, the property will be inherited from the default text style. Therefore, you can modify the default style to change the default style of all text items in your presentation. For example, the default color of text can be changed globally like this: default_style = slides.get_style(\"default\") default_style.color = \"orange\" slides.set_style(\"default\", default_style) slide = slides.new_slide(\"slide\") slide.text(\"Hello world!\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Predefined text styles"},{"location":"userguide/text/#updating-named-text-styles","text":"Since it is a common pattern to get an existing text style by name and update it, Elsie provides a shortcut method for this scenario: update_style : slides.update_style(\"default\", elsie.TextStyle(color=\"orange\")) # is the same as default_style = slides.get_style(\"default\") default_style.color = \"orange\" slides.set_style(\"default\", default_style) If you work with individual TextStyle instances, you can compose them together using the compose method: style_a = elsie.TextStyle(color=\"red\") style_b = style_a.compose(elsie.TestStyle(size=20)) # style_b has color=\"red\" and size=20","title":"Updating named text styles"},{"location":"userguide/text/#inline-text-styles","text":"Named styles are especially useful for changing individual sections of text inside a single string passed to the text method. To do this, wrap a section of text that you want to be styled differently with ~<style>{<text>} where style is a name of a style and text is some section of text. slide.set_style(\"red\", elsie.TextStyle(color=\"red\")) slide.text(\"Normal text ~red{red text} ~tt{Typewriter text}\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } Inline styles can also be nested arbitrarily. In this case the nested styles will be composed together: slide.set_style(\"red\", elsie.TextStyle(color=\"red\")) slide.text(\"~red{text1 ~tt{text2}}\") .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; } You can escape the inline style character (by default ~ ) by repeating it (e.g. \"~~\" ). If you need to use the ~ character a lot in your text, you can change it to a different character using the escape_character parameter of the text method.","title":"Inline text styles"},{"location":"userguide/text/#text-scaling","text":"By default, the size of text is determined by the size defined in its text style. This can be changed by the parameter scale_to_fit , which will scale the text to fit the size of its parent box. slide.box(width=200, height=80).text(\"Hello world!\", scale_to_fit=True) slide.box(width=80, height=200).text(\"Hello world!\", scale_to_fit=True) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Text scaling"},{"location":"userguide/text/#text-rotation","text":"You can use the rotation parameter to rotate the text by the given angle (in degrees) clockwise around its center. slide.box().text(\"Hello world!\", rotation=45) .elsie-wrapper { margin-bottom: 20px; } .elsie-slide { margin-bottom: 10px; } .elsie-controls { display: flex; align-items: center; } .elsie-controls * { margin: 0 10px; }","title":"Text rotation"},{"location":"userguide/text/#colors","text":"You can define the color of text, shapes and other things using a string that is compatible with SVG. You can use one of the following variants of color definitions: Color name: e.g. green , blue . See list of recognized SVG color names. Hex color value: e.g. #fff , #a0a0a0 . RGB values: e.g. rgb(34, 12, 64, 0.6) . HSL values: e.g. hsl(30, 100%, 50%, 0.6) .","title":"Colors"}]}